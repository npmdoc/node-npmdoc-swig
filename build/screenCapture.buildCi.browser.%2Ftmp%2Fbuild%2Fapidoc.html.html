<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/paularmstrong/swig">swig (v1.4.2)</a>
</h1>
<h4>A simple, powerful, and extendable templating engine for node.js and browsers, similar to Django, Jinja2, and Twig.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig">module swig</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.Swig">
            function <span class="apidocSignatureSpan">swig.</span>Swig
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.compile">
            function <span class="apidocSignatureSpan">swig.</span>compile
            <span class="apidocSignatureSpan">(source, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.compileFile">
            function <span class="apidocSignatureSpan">swig.</span>compileFile
            <span class="apidocSignatureSpan">(pathname, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.invalidateCache">
            function <span class="apidocSignatureSpan">swig.</span>invalidateCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.parseFile">
            function <span class="apidocSignatureSpan">swig.</span>parseFile
            <span class="apidocSignatureSpan">(pathname, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.precompile">
            function <span class="apidocSignatureSpan">swig.</span>precompile
            <span class="apidocSignatureSpan">(source, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.render">
            function <span class="apidocSignatureSpan">swig.</span>render
            <span class="apidocSignatureSpan">(source, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.renderFile">
            function <span class="apidocSignatureSpan">swig.</span>renderFile
            <span class="apidocSignatureSpan">(pathName, locals, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.run">
            function <span class="apidocSignatureSpan">swig.</span>run
            <span class="apidocSignatureSpan">(tpl, locals, filepath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.setDefaultTZOffset">
            function <span class="apidocSignatureSpan">swig.</span>setDefaultTZOffset
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.setDefaults">
            function <span class="apidocSignatureSpan">swig.</span>setDefaults
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.setExtension">
            function <span class="apidocSignatureSpan">swig.</span>setExtension
            <span class="apidocSignatureSpan">(name, object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.setFilter">
            function <span class="apidocSignatureSpan">swig.</span>setFilter
            <span class="apidocSignatureSpan">(name, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.setTag">
            function <span class="apidocSignatureSpan">swig.</span>setTag
            <span class="apidocSignatureSpan">(name, parse, compile, ends, blockLevel)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>swig</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>autoescape</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>block</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>dateformatter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>else</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>elseif</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>extends</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>filter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>filters</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>for</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>if</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>import</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>include</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>lexer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>loaders</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>macro</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>parent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>raw</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>set</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>spaceless</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swig.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.autoescape">module swig.autoescape</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swig.autoescape.</span>ends</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.autoescape.compile">
            function <span class="apidocSignatureSpan">swig.autoescape.</span>compile
            <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.autoescape.parse">
            function <span class="apidocSignatureSpan">swig.autoescape.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser, types, stack, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.block">module swig.block</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swig.</span>block</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swig.block.</span>ends</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.block.compile">
            function <span class="apidocSignatureSpan">swig.block.</span>compile
            <span class="apidocSignatureSpan">(compiler, args, content, parents, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.block.parse">
            function <span class="apidocSignatureSpan">swig.block.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.dateformatter">module swig.dateformatter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.A">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>A
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.B">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>B
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.D">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>D
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.DateZ">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>DateZ
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.F">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>F
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.G">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>G
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.H">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>H
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.L">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>L
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.M">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>M
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.N">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>N
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.O">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>O
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.S">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>S
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.U">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>U
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.W">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>W
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.Y">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>Y
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.Z">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>Z
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.a">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>a
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.c">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>c
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.d">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>d
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.g">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>g
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.h">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>h
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.i">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>i
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.j">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>j
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.l">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>l
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.m">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>m
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.n">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>n
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.o">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>o
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.r">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>r
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.s">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>s
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.t">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>t
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.w">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>w
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.y">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>y
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.dateformatter.z">
            function <span class="apidocSignatureSpan">swig.dateformatter.</span>z
            <span class="apidocSignatureSpan">(input, offset, abbr)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">swig.dateformatter.</span>tzOffset</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.else">module swig.else</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.else.compile">
            function <span class="apidocSignatureSpan">swig.else.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.else.parse">
            function <span class="apidocSignatureSpan">swig.else.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser, types, stack)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.elseif">module swig.elseif</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.elseif.compile">
            function <span class="apidocSignatureSpan">swig.elseif.</span>compile
            <span class="apidocSignatureSpan">(compiler, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.elseif.parse">
            function <span class="apidocSignatureSpan">swig.elseif.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser, types, stack)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.extends">module swig.extends</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swig.extends.</span>ends</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.extends.compile">
            function <span class="apidocSignatureSpan">swig.extends.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.extends.parse">
            function <span class="apidocSignatureSpan">swig.extends.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.filter">module swig.filter</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swig.filter.</span>ends</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filter.compile">
            function <span class="apidocSignatureSpan">swig.filter.</span>compile
            <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filter.parse">
            function <span class="apidocSignatureSpan">swig.filter.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser, types)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.filters">module swig.filters</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.addslashes">
            function <span class="apidocSignatureSpan">swig.filters.</span>addslashes
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.capitalize">
            function <span class="apidocSignatureSpan">swig.filters.</span>capitalize
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.date">
            function <span class="apidocSignatureSpan">swig.filters.</span>date
            <span class="apidocSignatureSpan">(input, format, offset, abbr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.default">
            function <span class="apidocSignatureSpan">swig.filters.</span>default
            <span class="apidocSignatureSpan">(input, def)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.e">
            function <span class="apidocSignatureSpan">swig.filters.</span>e
            <span class="apidocSignatureSpan">(input, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.escape">
            function <span class="apidocSignatureSpan">swig.filters.</span>escape
            <span class="apidocSignatureSpan">(input, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.first">
            function <span class="apidocSignatureSpan">swig.filters.</span>first
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.groupBy">
            function <span class="apidocSignatureSpan">swig.filters.</span>groupBy
            <span class="apidocSignatureSpan">(input, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.join">
            function <span class="apidocSignatureSpan">swig.filters.</span>join
            <span class="apidocSignatureSpan">(input, glue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.json">
            function <span class="apidocSignatureSpan">swig.filters.</span>json
            <span class="apidocSignatureSpan">(input, indent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.json_encode">
            function <span class="apidocSignatureSpan">swig.filters.</span>json_encode
            <span class="apidocSignatureSpan">(input, indent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.last">
            function <span class="apidocSignatureSpan">swig.filters.</span>last
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.lower">
            function <span class="apidocSignatureSpan">swig.filters.</span>lower
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.raw">
            function <span class="apidocSignatureSpan">swig.filters.</span>raw
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.replace">
            function <span class="apidocSignatureSpan">swig.filters.</span>replace
            <span class="apidocSignatureSpan">(input, search, replacement, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.reverse">
            function <span class="apidocSignatureSpan">swig.filters.</span>reverse
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.safe">
            function <span class="apidocSignatureSpan">swig.filters.</span>safe
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.sort">
            function <span class="apidocSignatureSpan">swig.filters.</span>sort
            <span class="apidocSignatureSpan">(input, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.striptags">
            function <span class="apidocSignatureSpan">swig.filters.</span>striptags
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.title">
            function <span class="apidocSignatureSpan">swig.filters.</span>title
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.uniq">
            function <span class="apidocSignatureSpan">swig.filters.</span>uniq
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.upper">
            function <span class="apidocSignatureSpan">swig.filters.</span>upper
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.url_decode">
            function <span class="apidocSignatureSpan">swig.filters.</span>url_decode
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.filters.url_encode">
            function <span class="apidocSignatureSpan">swig.filters.</span>url_encode
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.for">module swig.for</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swig.for.</span>ends</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.for.compile">
            function <span class="apidocSignatureSpan">swig.for.</span>compile
            <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.for.parse">
            function <span class="apidocSignatureSpan">swig.for.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser, types)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.if">module swig.if</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swig.if.</span>ends</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.if.compile">
            function <span class="apidocSignatureSpan">swig.if.</span>compile
            <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.if.parse">
            function <span class="apidocSignatureSpan">swig.if.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser, types)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.import">module swig.import</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swig.import.</span>block</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.import.compile">
            function <span class="apidocSignatureSpan">swig.import.</span>compile
            <span class="apidocSignatureSpan">(compiler, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.import.parse">
            function <span class="apidocSignatureSpan">swig.import.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser, types, stack, opts, swig)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.include">module swig.include</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.include.compile">
            function <span class="apidocSignatureSpan">swig.include.</span>compile
            <span class="apidocSignatureSpan">(compiler, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.include.parse">
            function <span class="apidocSignatureSpan">swig.include.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser, types, stack, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.lexer">module swig.lexer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.lexer.read">
            function <span class="apidocSignatureSpan">swig.lexer.</span>read
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.lexer.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.loaders">module swig.loaders</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.loaders.fs">
            function <span class="apidocSignatureSpan">swig.loaders.</span>fs
            <span class="apidocSignatureSpan">(basepath, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.loaders.memory">
            function <span class="apidocSignatureSpan">swig.loaders.</span>memory
            <span class="apidocSignatureSpan">(mapping, basepath)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.macro">module swig.macro</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swig.macro.</span>block</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swig.macro.</span>ends</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.macro.compile">
            function <span class="apidocSignatureSpan">swig.macro.</span>compile
            <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.macro.parse">
            function <span class="apidocSignatureSpan">swig.macro.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser, types)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.parent">module swig.parent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.parent.compile">
            function <span class="apidocSignatureSpan">swig.parent.</span>compile
            <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.parent.parse">
            function <span class="apidocSignatureSpan">swig.parent.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser, types, stack, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.parser">module swig.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.parser.compile">
            function <span class="apidocSignatureSpan">swig.parser.</span>compile
            <span class="apidocSignatureSpan">(template, parents, options, blockName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.parser.parse">
            function <span class="apidocSignatureSpan">swig.parser.</span>parse
            <span class="apidocSignatureSpan">(swig, source, opts, tags, filters)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.raw">module swig.raw</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swig.raw.</span>ends</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.raw.compile">
            function <span class="apidocSignatureSpan">swig.raw.</span>compile
            <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.raw.parse">
            function <span class="apidocSignatureSpan">swig.raw.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.set">module swig.set</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swig.set.</span>block</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.set.compile">
            function <span class="apidocSignatureSpan">swig.set.</span>compile
            <span class="apidocSignatureSpan">(compiler, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.set.parse">
            function <span class="apidocSignatureSpan">swig.set.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser, types)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.spaceless">module swig.spaceless</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swig.spaceless.</span>ends</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.spaceless.compile">
            function <span class="apidocSignatureSpan">swig.spaceless.</span>compile
            <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.spaceless.parse">
            function <span class="apidocSignatureSpan">swig.spaceless.</span>parse
            <span class="apidocSignatureSpan">(str, line, parser)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.swig">module swig.swig</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.Swig">
            function <span class="apidocSignatureSpan">swig.swig.</span>Swig
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.compile">
            function <span class="apidocSignatureSpan">swig.swig.</span>compile
            <span class="apidocSignatureSpan">(source, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.compileFile">
            function <span class="apidocSignatureSpan">swig.swig.</span>compileFile
            <span class="apidocSignatureSpan">(pathname, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.invalidateCache">
            function <span class="apidocSignatureSpan">swig.swig.</span>invalidateCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.parseFile">
            function <span class="apidocSignatureSpan">swig.swig.</span>parseFile
            <span class="apidocSignatureSpan">(pathname, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.precompile">
            function <span class="apidocSignatureSpan">swig.swig.</span>precompile
            <span class="apidocSignatureSpan">(source, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.render">
            function <span class="apidocSignatureSpan">swig.swig.</span>render
            <span class="apidocSignatureSpan">(source, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.renderFile">
            function <span class="apidocSignatureSpan">swig.swig.</span>renderFile
            <span class="apidocSignatureSpan">(pathName, locals, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.run">
            function <span class="apidocSignatureSpan">swig.swig.</span>run
            <span class="apidocSignatureSpan">(tpl, locals, filepath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.setDefaultTZOffset">
            function <span class="apidocSignatureSpan">swig.swig.</span>setDefaultTZOffset
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.setDefaults">
            function <span class="apidocSignatureSpan">swig.swig.</span>setDefaults
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.setExtension">
            function <span class="apidocSignatureSpan">swig.swig.</span>setExtension
            <span class="apidocSignatureSpan">(name, object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.setFilter">
            function <span class="apidocSignatureSpan">swig.swig.</span>setFilter
            <span class="apidocSignatureSpan">(name, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.swig.setTag">
            function <span class="apidocSignatureSpan">swig.swig.</span>setTag
            <span class="apidocSignatureSpan">(name, parse, compile, ends, blockLevel)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swig.swig.</span>loaders</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swig.swig.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swig.utils">module swig.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.utils.each">
            function <span class="apidocSignatureSpan">swig.utils.</span>each
            <span class="apidocSignatureSpan">(obj, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.utils.endsWith">
            function <span class="apidocSignatureSpan">swig.utils.</span>endsWith
            <span class="apidocSignatureSpan">(str, suffix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.utils.extend">
            function <span class="apidocSignatureSpan">swig.utils.</span>extend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.utils.isArray">
            function <span class="apidocSignatureSpan">swig.utils.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.utils.keys">
            function <span class="apidocSignatureSpan">swig.utils.</span>keys
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.utils.map">
            function <span class="apidocSignatureSpan">swig.utils.</span>map
            <span class="apidocSignatureSpan">(obj, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.utils.some">
            function <span class="apidocSignatureSpan">swig.utils.</span>some
            <span class="apidocSignatureSpan">(obj, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.utils.startsWith">
            function <span class="apidocSignatureSpan">swig.utils.</span>startsWith
            <span class="apidocSignatureSpan">(str, prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.utils.strip">
            function <span class="apidocSignatureSpan">swig.utils.</span>strip
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swig.utils.throwError">
            function <span class="apidocSignatureSpan">swig.utils.</span>throwError
            <span class="apidocSignatureSpan">(message, line, file)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig" id="apidoc.module.swig">module swig</a></h1>


    <h2>
        <a href="#apidoc.element.swig.Swig" id="apidoc.element.swig.Swig">
        function <span class="apidocSignatureSpan">swig.</span>Swig
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Swig = function (opts) {
  validateOptions(opts);
  this.options = utils.extend({}, defaultOptions, opts || {});
  this.cache = {};
  this.extensions = {};
  var self = this,
    tags = _tags,
    filters = _filters;

<span class="apidocCodeCommentSpan">  /**
   * Get combined locals context.
   * @param  {?SwigOpts} [options] Swig options object.
   * @return {object}         Locals context.
   * @private
   */
</span>  function getLocals(options) {
    if (!options || !options.locals) {
      return self.options.locals;
    }

    return utils.extend({}, self.options.locals, options.locals);
  }

  /**
   * Determine whether caching is enabled via the options provided and/or defaults
   * @param  {SwigOpts} [options={}] Swig Options Object
   * @return {boolean}
   * @private
   */
  function shouldCache(options) {
    options = options || {};
    return (options.hasOwnProperty('cache') &amp;&amp; !options.cache) || !self.options.cache;
  }

  /**
   * Get compiled template from the cache.
   * @param  {string} key           Name of template.
   * @return {object|undefined}     Template function and tokens.
   * @private
   */
  function cacheGet(key, options) {
    if (shouldCache(options)) {
      return;
    }

    if (self.options.cache === 'memory') {
      return self.cache[key];
    }

    return self.options.cache.get(key);
  }

  /**
   * Store a template in the cache.
   * @param  {string} key Name of template.
   * @param  {object} val Template function and tokens.
   * @return {undefined}
   * @private
   */
  function cacheSet(key, options, val) {
    if (shouldCache(options)) {
      return;
    }

    if (self.options.cache === 'memory') {
      self.cache[key] = val;
      return;
    }

    self.options.cache.set(key, val);
  }

  /**
   * Clears the in-memory template cache.
   *
   * @example
   * swig.invalidateCache();
   *
   * @return {undefined}
   */
  this.invalidateCache = function () {
    if (self.options.cache === 'memory') {
      self.cache = {};
    }
  };

  /**
   * Add a custom filter for swig variables.
   *
   * @example
   * function replaceMs(input) { return input.replace(/m/g, 'f'); }
   * swig.setFilter('replaceMs', replaceMs);
   * // =&gt; {{ "onomatopoeia"|replaceMs }}
   * // =&gt; onofatopeia
   *
   * @param {string}    name    Name of filter, used in templates. &lt;strong&gt;Will&lt;/strong&gt; overwrite previously defined filters, if
 using the same name.
   * @param {function}  method  Function that acts against the input. See &lt;a href="/docs/filters/#custom"&gt;Custom Filters&lt;/a&gt; for
 more information.
   * @return {undefined}
   */
  this.setFilter = function (name, method) {
    if (typeof method !== "function") {
      throw new Error('Filter "' + name + '" is not a valid function.');
    }
    filters[name] = method;
  };

  /**
   * Add a custom tag. To expose your own extensions to compiled template code, see &lt;code data-language="js"&gt;swig.setExtension&lt;/
code&gt;.
   *
   * For a more in-depth explanation of writing custom tags, see &lt;a href="../extending/#tags"&gt;Custom Tags&lt;/a&gt;.
   *
   * @example
   * var tacotag = require('./tacotag');
   * swig.setTag('tacos', tacotag.parse, tacotag.compile, tacotag.ends, tacotag.blockLevel);
   * // =&gt; {% tacos %}Make this be tacos.{% endtacos %}
   * // =&gt; Tacos tacos tacos tacos.
   *
   * @param  {string} name      Tag name.
   * @param  {function} parse   Method for parsing tokens.
   * @param  {function} compile Method for compiling renderable output.
   * @param  {boolean} [ends=false]     Whether or not this tag requires an &lt;i&gt;end&lt;/i&gt; tag.
   * @param  {boolean} [blockLevel=false] If false, this tag will not be compiled outside of &lt;code&gt;block&lt;/code&gt; tags when extending
 a parent template.
   * @return {undefined}
   */
  this.setTag = function (name, parse, compile, ends, blockLevel) {
    if (typeof parse !== 'function') {
      throw new Error('Tag "' + name + '" parse method is not a valid function.');
    }

    if (typeof compile !== 'function') {
      throw new Error('Tag "' + name + '" compile method is not a valid function.');
    }

    tags[name] = {
      parse: parse,
      compile: compi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Create a new, separate Swig compile/render environment.
*
* @example
* var swig = require('swig');
* var myswig = new swig.<span class="apidocCodeKeywordSpan">Swig</span>({varControls: ['&lt;%=', '%&gt;']});
* myswig.render('Tacos are &lt;%= tacos =&gt;!', { locals: { tacos: 'delicious' }});
* // =&gt; Tacos are delicious!
* swig.render('Tacos are &lt;%= tacos =&gt;!', { locals: { tacos: 'delicious' }});
* // =&gt; 'Tacos are &lt;%= tacos =&gt;!'
*
* @param  {SwigOpts} [opts={}] Swig options object.
* @return {object}      New Swig environment.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.compile" id="apidoc.element.swig.compile">
        function <span class="apidocSignatureSpan">swig.</span>compile
        <span class="apidocSignatureSpan">(source, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (source, options) {
  var key = options ? options.filename : null,
    cached = key ? cacheGet(key, options) : null,
    context,
    contextLength,
    pre;

  if (cached) {
    return cached;
  }

  context = getLocals(options);
  contextLength = utils.keys(context).length;
  pre = this.precompile(source, options);

  function compiled(locals) {
    var lcls;
    if (locals &amp;&amp; contextLength) {
      lcls = utils.extend({}, context, locals);
    } else if (locals &amp;&amp; !contextLength) {
      lcls = locals;
    } else if (!locals &amp;&amp; contextLength) {
      lcls = context;
    } else {
      lcls = {};
    }
    return pre.tpl(self, lcls, filters, utils, efn);
  }

  utils.extend(compiled, pre.tokens);

  if (key) {
    cacheSet(key, options, compiled);
  }

  return compiled;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.compileFile" id="apidoc.element.swig.compileFile">
        function <span class="apidocSignatureSpan">swig.</span>compileFile
        <span class="apidocSignatureSpan">(pathname, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileFile = function (pathname, options, cb) {
  var src, cached;

  if (!options) {
    options = {};
  }

  pathname = self.options.loader.resolve(pathname, options.resolveFrom);
  if (!options.filename) {
    options = utils.extend({ filename: pathname }, options);
  }
  cached = cacheGet(pathname, options);

  if (cached) {
    if (cb) {
      cb(null, cached);
      return;
    }
    return cached;
  }

  if (cb) {
    self.options.loader.load(pathname, function (err, src) {
      if (err) {
        cb(err);
        return;
      }
      var compiled;

      try {
        compiled = self.compile(src, options);
      } catch (err2) {
        cb(err2);
        return;
      }

      cb(err, compiled);
    });
    return;
  }

  src = self.options.loader.load(pathname);
  return self.compile(src, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;/ul&gt;
```

### node.js code

```js
var swig  = require('swig');
var template = swig.<span class="apidocCodeKeywordSpan">compileFile</span>('/absolute/path/to/template.html');
var output = template({
    pagename: 'awesome people',
    authors: ['Paul', 'Jim', 'Jane']
});
```

### Output
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.invalidateCache" id="apidoc.element.swig.invalidateCache">
        function <span class="apidocSignatureSpan">swig.</span>invalidateCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invalidateCache = function () {
  if (self.options.cache === 'memory') {
    self.cache = {};
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.options.cache.set(key, val);
}

/**
 * Clears the in-memory template cache.
 *
 * @example
 * swig.<span class="apidocCodeKeywordSpan">invalidateCache</span>();
 *
 * @return {undefined}
 */
this.invalidateCache = function () {
  if (self.options.cache === 'memory') {
    self.cache = {};
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.parseFile" id="apidoc.element.swig.parseFile">
        function <span class="apidocSignatureSpan">swig.</span>parseFile
        <span class="apidocSignatureSpan">(pathname, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFile = function (pathname, options) {
  var src;

  if (!options) {
    options = {};
  }

  pathname = self.options.loader.resolve(pathname, options.resolveFrom);

  src = self.options.loader.load(pathname);

  if (!options.filename) {
    options = utils.extend({ filename: pathname }, options);
  }

  return self.parse(src, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    while (parentName) {
if (!options || !options.filename) {
  throw new Error('Cannot extend "' + parentName + '" because current template has no filename.');
}

parentFile = parentFile || options.filename;
parentFile = self.options.loader.resolve(parentName, parentFile);
parent = cacheGet(parentFile, options) || self.<span class="apidocCodeKeywordSpan">parseFile</span>(parentFile, utils.extend({},
options, { filename: parentFile }));
parentName = parent.parent;

if (parentFiles.indexOf(parentFile) !== -1) {
  throw new Error('Illegal circular extends of "' + parentFile + '".');
}
parentFiles.push(parentFile);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.precompile" id="apidoc.element.swig.precompile">
        function <span class="apidocSignatureSpan">swig.</span>precompile
        <span class="apidocSignatureSpan">(source, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">precompile = function (source, options) {
  var tokens = self.parse(source, options),
    parents = getParents(tokens, options),
    tpl,
    err;

  if (parents.length) {
    // Remap the templates first-parent's tokens using this template's blocks.
    tokens.tokens = remapBlocks(tokens.blocks, parents[0].tokens);
    importNonBlocks(tokens.blocks, tokens.tokens);
  }

  try {
    tpl = new Function('_swig', '_ctx', '_filters', '_utils', '_fn',
      '  var _ext = _swig.extensions,\n' +
      '    _output = "";\n' +
      parser.compile(tokens, parents, options) + '\n' +
      '  return _output;\n'
      );
  } catch (e) {
    utils.throwError(e, null, options.filename);
  }

  return { tpl: tpl, tokens: tokens };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.options) {
  swig.setDefaults(require(argv.options));
}

switch (command) {
case 'compile':
  fn = function (file, str) {
var r = swig.<span class="apidocCodeKeywordSpan">precompile</span>(str, { filename: file, locals: ctx }).tpl.toString().replace(&amp;#
x27;anonymous', '');

r = argv['wrap-start'] + r + argv['wrap-end'];

if (argv.m) {
  r = uglify.minify(r, { fromString: true }).code;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.render" id="apidoc.element.swig.render">
        function <span class="apidocSignatureSpan">swig.</span>render
        <span class="apidocSignatureSpan">(source, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (source, options) {
  return self.compile(source, options)();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    out(file, __tpl(swig, ctx, filters, utils, efn));
  }());
};
break;

case 'render':
fn = function (file, str) {
  out(file, swig.<span class="apidocCodeKeywordSpan">render</span>(str, { filename: file, locals: ctx }));
};
break;
}

argv._.forEach(function (file) {
var str = fs.readFileSync(file, 'utf8');
fn(file, str);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.renderFile" id="apidoc.element.swig.renderFile">
        function <span class="apidocSignatureSpan">swig.</span>renderFile
        <span class="apidocSignatureSpan">(pathName, locals, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderFile = function (pathName, locals, cb) {
  if (cb) {
    self.compileFile(pathName, {}, function (err, fn) {
      var result;

      if (err) {
        cb(err);
        return;
      }

      try {
        result = fn(locals);
      } catch (err2) {
        cb(err2);
        return;
      }

      cb(null, result);
    });
    return;
  }

  return self.compileFile(pathName)(locals);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return self.compile(source, options)();
};

/**
 * Compile and render a template file for final output. This is most useful for libraries like Express.js.
 *
 * @example
 * swig.<span class="apidocCodeKeywordSpan">renderFile</span>('./template.html', {}, function (err, output) {
 *   if (err) {
 *     throw err;
 *   }
 *   console.log(output);
 * });
 *
 * @example
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.run" id="apidoc.element.swig.run">
        function <span class="apidocSignatureSpan">swig.</span>run
        <span class="apidocSignatureSpan">(tpl, locals, filepath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (tpl, locals, filepath) {
  var context = getLocals({ locals: locals });
  if (filepath) {
    cacheSet(filepath, {}, tpl);
  }
  return tpl(self, context, filters, utils, efn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Run a pre-compiled template function. This is most useful in the browser when you've pre-compiled your templates with the
 Swig command-line tool.
*
* @example
* $ swig compile ./mytpl.html --wrap-start="var mytpl = " &gt; mytpl.js
* @example
* &lt;script src="mytpl.js"&gt;&lt;/script&gt;
* &lt;script&gt;
*   swig.<span class="apidocCodeKeywordSpan">run</span>(mytpl, {});
*   // =&gt; "rendered template..."
* &lt;/script&gt;
*
* @param  {function} tpl       Pre-compiled Swig template function. Use the Swig CLI to compile your templates.
* @param  {object} [locals={}] Template variable context.
* @param  {string} [filepath]  Filename used for caching the template.
* @return {string}             Rendered output.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.setDefaultTZOffset" id="apidoc.element.swig.setDefaultTZOffset">
        function <span class="apidocSignatureSpan">swig.</span>setDefaultTZOffset
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDefaultTZOffset = function (offset) {
  dateformatter.tzOffset = offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.setDefaults" id="apidoc.element.swig.setDefaults">
        function <span class="apidocSignatureSpan">swig.</span>setDefaults
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDefaults = function (options) {
  validateOptions(options);
  defaultInstance.options = utils.extend(defaultInstance.options, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
utils.each(require(path.resolve(argv.tags)), function (tag, name) {
  swig.setTag(name, tag.parse, tag.compile, tag.ends, tag.block);
});
}

// Specify swig default options
if (argv.options) {
swig.<span class="apidocCodeKeywordSpan">setDefaults</span>(require(argv.options));
}

switch (command) {
case 'compile':
fn = function (file, str) {
  var r = swig.precompile(str, { filename: file, locals: ctx }).tpl.toString().replace('anonymous', '');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.setExtension" id="apidoc.element.swig.setExtension">
        function <span class="apidocSignatureSpan">swig.</span>setExtension
        <span class="apidocSignatureSpan">(name, object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setExtension = function (name, object) {
  self.extensions[name] = object;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
};

/**
 * Add extensions for custom tags. This allows any custom tag to access a globally available methods via a special globally available
 object, &lt;var&gt;_ext&lt;/var&gt;, in templates.
 *
 * @example
 * swig.<span class="apidocCodeKeywordSpan">setExtension</span>('trans', function (v) { return translate(v); });
 * function compileTrans(compiler, args, content, parent, options) {
 *   return '_output += _ext.trans(' + args[0] + ');'
 * };
 * swig.setTag('trans', parseTrans, compileTrans, true);
 *
 * @param  {string} name   Key name of the extension. Accessed via &lt;code data-language="js"&gt;_ext[name]&lt;/
code&gt;.
 * @param  {*}      object The method, value, or object that should be available via the given name.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.setFilter" id="apidoc.element.swig.setFilter">
        function <span class="apidocSignatureSpan">swig.</span>setFilter
        <span class="apidocSignatureSpan">(name, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFilter = function (name, method) {
  if (typeof method !== "function") {
    throw new Error('Filter "' + name + '" is not a valid function.');
  }
  filters[name] = method;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.log('Wrote', argv.o + file);
};
}

// Set any custom filters
if (argv.filters) {
utils.each(require(path.resolve(argv.filters)), function (filter, name) {
  swig.<span class="apidocCodeKeywordSpan">setFilter</span>(name, filter);
});
}

// Set any custom tags
if (argv.tags) {
utils.each(require(path.resolve(argv.tags)), function (tag, name) {
  swig.setTag(name, tag.parse, tag.compile, tag.ends, tag.block);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.setTag" id="apidoc.element.swig.setTag">
        function <span class="apidocSignatureSpan">swig.</span>setTag
        <span class="apidocSignatureSpan">(name, parse, compile, ends, blockLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTag = function (name, parse, compile, ends, blockLevel) {
  if (typeof parse !== 'function') {
    throw new Error('Tag "' + name + '" parse method is not a valid function.');
  }

  if (typeof compile !== 'function') {
    throw new Error('Tag "' + name + '" compile method is not a valid function.');
  }

  tags[name] = {
    parse: parse,
    compile: compile,
    ends: ends || false,
    block: !!blockLevel
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    swig.setFilter(name, filter);
  });
}

// Set any custom tags
if (argv.tags) {
  utils.each(require(path.resolve(argv.tags)), function (tag, name) {
    swig.<span class="apidocCodeKeywordSpan">setTag</span>(name, tag.parse, tag.compile, tag.ends, tag.block);
  });
}

// Specify swig default options
if (argv.options) {
  swig.setDefaults(require(argv.options));
}
...</pre></li>
    </ul>
















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.autoescape" id="apidoc.module.swig.autoescape">module swig.autoescape</a></h1>




    <h2>
        <a href="#apidoc.element.swig.autoescape.compile" id="apidoc.element.swig.autoescape.compile">
        function <span class="apidocSignatureSpan">swig.autoescape.</span>compile
        <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (compiler, args, content, parents, options, blockName) {
  return compiler(content, parents, options, blockName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.autoescape.parse" id="apidoc.element.swig.autoescape.parse">
        function <span class="apidocSignatureSpan">swig.autoescape.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser, types, stack, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser, types, stack, opts) {
  var matched;
  parser.on('*', function (token) {
    if (!matched &amp;&amp;
        (token.type === types.BOOL ||
          (token.type === types.STRING &amp;&amp; strings.indexOf(token.match) === -1))
        ) {
      this.out.push(token.match);
      matched = true;
      return;
    }
    utils.throwError('Unexpected token "' + token.match + '" in autoescape tag', line, opts.filename);
  });

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.block" id="apidoc.module.swig.block">module swig.block</a></h1>






    <h2>
        <a href="#apidoc.element.swig.block.compile" id="apidoc.element.swig.block.compile">
        function <span class="apidocSignatureSpan">swig.block.</span>compile
        <span class="apidocSignatureSpan">(compiler, args, content, parents, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (compiler, args, content, parents, options) {
  return compiler(content, parents, options, args.join(''));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.block.parse" id="apidoc.element.swig.block.parse">
        function <span class="apidocSignatureSpan">swig.block.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser) {
  parser.on('*', function (token) {
    this.out.push(token.match);
  });
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.dateformatter" id="apidoc.module.swig.dateformatter">module swig.dateformatter</a></h1>


    <h2>
        <a href="#apidoc.element.swig.dateformatter.A" id="apidoc.element.swig.dateformatter.A">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>A
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">A = function (input) {
  return input.getHours() &lt; 12 ? 'AM' : 'PM';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.B" id="apidoc.element.swig.dateformatter.B">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>B
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">B = function (input) {
  var hours = input.getUTCHours(), beats;
  hours = (hours === 23) ? 0 : hours + 1;
  beats = Math.abs(((((hours * 60) + input.getUTCMinutes()) * 60) + input.getUTCSeconds()) / 86.4).toFixed(0);
  return ('000'.concat(beats).slice(beats.length));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.D" id="apidoc.element.swig.dateformatter.D">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>D
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">D = function (input) {
  return _days.abbr[input.getDay()];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.DateZ" id="apidoc.element.swig.dateformatter.DateZ">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>DateZ
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DateZ = function () {
  var members = {
      'default': ['getUTCDate', 'getUTCDay', 'getUTCFullYear', 'getUTCHours', 'getUTCMilliseconds', 'getUTCMinutes', 'getUTCMonth
', 'getUTCSeconds', 'toISOString', 'toGMTString', 'toUTCString', 'valueOf', 'getTime'],
      z: ['getDate', 'getDay', 'getFullYear', 'getHours', 'getMilliseconds', 'getMinutes', 'getMonth', 'getSeconds', 'getYear', '
toDateString', 'toLocaleDateString', 'toLocaleTimeString']
    },
    d = this;

  d.date = d.dateZ = (arguments.length &gt; 1) ? new Date(Date.UTC.apply(Date, arguments) + ((new Date()).getTimezoneOffset() * 60000
)) : (arguments.length === 1) ? new Date(new Date(arguments['0'])) : new Date();

  d.timezoneOffset = d.dateZ.getTimezoneOffset();

  utils.each(members.z, function (name) {
    d[name] = function () {
      return d.dateZ[name]();
    };
  });
  utils.each(members['default'], function (name) {
    d[name] = function () {
      return d.date[name]();
    };
  });

  this.setTimezoneOffset(exports.tzOffset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (d % 10 === 1 &amp;&amp; d !== 11 ? 'st' : (d % 10 === 2 &amp;&amp; d !== 12 ? 'nd' : (d % 10 ===
3 &amp;&amp; d !== 13 ? 'rd' : 'th')));
};
exports.w = function (input) {
  return input.getDay();
};
exports.z = function (input, offset, abbr) {
  var year = input.getFullYear(),
    e = new exports.<span class="apidocCodeKeywordSpan">DateZ</span>(year, input.getMonth(), input.getDate(), 12, 0, 0),
    d = new exports.DateZ(year, 0, 1, 12, 0, 0);

  e.setTimezoneOffset(offset, abbr);
  d.setTimezoneOffset(offset, abbr);
  return Math.round((e - d) / 86400000);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.F" id="apidoc.element.swig.dateformatter.F">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>F
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">F = function (input) {
  return _months.full[input.getMonth()];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.G" id="apidoc.element.swig.dateformatter.G">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>G
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">G = function (input) {
  return input.getHours();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.H" id="apidoc.element.swig.dateformatter.H">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>H
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">H = function (input) {
  var h = input.getHours();
  return (h &lt; 10 ? '0' : '') + h;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.L" id="apidoc.element.swig.dateformatter.L">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>L
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">L = function (input) {
  return new Date(input.getFullYear(), 1, 29).getDate() === 29;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.M" id="apidoc.element.swig.dateformatter.M">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>M
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">M = function (input) {
  return _months.abbr[input.getMonth()];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.N" id="apidoc.element.swig.dateformatter.N">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>N
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">N = function (input) {
  var d = input.getDay();
  return (d &gt;= 1) ? d : 7;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.O" id="apidoc.element.swig.dateformatter.O">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>O
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">O = function (input) {
  var tz = input.getTimezoneOffset();
  return (tz &lt; 0 ? '-' : '+') + (tz / 60 &lt; 10 ? '0' : '') + Math.abs((tz / 60)) + '00';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.S" id="apidoc.element.swig.dateformatter.S">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>S
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">S = function (input) {
  var d = input.getDate();
  return (d % 10 === 1 &amp;&amp; d !== 11 ? 'st' : (d % 10 === 2 &amp;&amp; d !== 12 ? 'nd' : (d % 10 === 3 &amp;&amp; d !== 13 ? 'rd' : 'th')));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.U" id="apidoc.element.swig.dateformatter.U">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>U
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">U = function (input) {
  return input.getTime() / 1000;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.W" id="apidoc.element.swig.dateformatter.W">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>W
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">W = function (input) {
  var target = new Date(input.valueOf()),
    dayNr = (input.getDay() + 6) % 7,
    fThurs;

  target.setDate(target.getDate() - dayNr + 3);
  fThurs = target.valueOf();
  target.setMonth(0, 1);
  if (target.getDay() !== 4) {
    target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);
  }

  return 1 + Math.ceil((fThurs - target) / 604800000);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.Y" id="apidoc.element.swig.dateformatter.Y">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>Y
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Y = function (input) {
  return input.getFullYear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.Z" id="apidoc.element.swig.dateformatter.Z">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>Z
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Z = function (input) {
  return input.getTimezoneOffset() * 60;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.a" id="apidoc.element.swig.dateformatter.a">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>a
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">a = function (input) {
  return input.getHours() &lt; 12 ? 'am' : 'pm';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.c" id="apidoc.element.swig.dateformatter.c">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>c
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">c = function (input) {
  return input.toISOString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.d" id="apidoc.element.swig.dateformatter.d">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>d
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">d = function (input) {
  return (input.getDate() &lt; 10 ? '0' : '') + input.getDate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.g" id="apidoc.element.swig.dateformatter.g">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>g
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">g = function (input) {
  var h = input.getHours();
  return h === 0 ? 12 : (h &gt; 12 ? h - 12 : h);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.h" id="apidoc.element.swig.dateformatter.h">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>h
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">h = function (input) {
  var h = input.getHours();
  return ((h &lt; 10 || (12 &lt; h &amp;&amp; 22 &gt; h)) ? '0' : '') + ((h &lt; 12) ? h : h - 12);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.i" id="apidoc.element.swig.dateformatter.i">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>i
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">i = function (input) {
  var m = input.getMinutes();
  return (m &lt; 10 ? '0' : '') + m;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.j" id="apidoc.element.swig.dateformatter.j">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>j
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">j = function (input) {
  return input.getDate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.l" id="apidoc.element.swig.dateformatter.l">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>l
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">l = function (input) {
  return _days.full[input.getDay()];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.m" id="apidoc.element.swig.dateformatter.m">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>m
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">m = function (input) {
  return (input.getMonth() &lt; 9 ? '0' : '') + (input.getMonth() + 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.n" id="apidoc.element.swig.dateformatter.n">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>n
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">n = function (input) {
  return input.getMonth() + 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.o" id="apidoc.element.swig.dateformatter.o">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>o
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">o = function (input) {
  var target = new Date(input.valueOf());
  target.setDate(target.getDate() - ((input.getDay() + 6) % 7) + 3);
  return target.getFullYear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.r" id="apidoc.element.swig.dateformatter.r">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>r
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">r = function (input) {
  return input.toUTCString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.s" id="apidoc.element.swig.dateformatter.s">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>s
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">s = function (input) {
  var s = input.getSeconds();
  return (s &lt; 10 ? '0' : '') + s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.t" id="apidoc.element.swig.dateformatter.t">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>t
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">t = function (input) {
  return 32 - (new Date(input.getFullYear(), input.getMonth(), 32).getDate());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.w" id="apidoc.element.swig.dateformatter.w">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>w
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">w = function (input) {
  return input.getDay();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.y" id="apidoc.element.swig.dateformatter.y">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>y
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">y = function (input) {
  return (input.getFullYear().toString()).substr(2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.dateformatter.z" id="apidoc.element.swig.dateformatter.z">
        function <span class="apidocSignatureSpan">swig.dateformatter.</span>z
        <span class="apidocSignatureSpan">(input, offset, abbr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">z = function (input, offset, abbr) {
  var year = input.getFullYear(),
    e = new exports.DateZ(year, input.getMonth(), input.getDate(), 12, 0, 0),
    d = new exports.DateZ(year, 0, 1, 12, 0, 0);

  e.setTimezoneOffset(offset, abbr);
  d.setTimezoneOffset(offset, abbr);
  return Math.round((e - d) / 86400000);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.else" id="apidoc.module.swig.else">module swig.else</a></h1>


    <h2>
        <a href="#apidoc.element.swig.else.compile" id="apidoc.element.swig.else.compile">
        function <span class="apidocSignatureSpan">swig.else.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function () {
  return '} else {\n';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.else.parse" id="apidoc.element.swig.else.parse">
        function <span class="apidocSignatureSpan">swig.else.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser, types, stack)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser, types, stack) {
  parser.on('*', function (token) {
    throw new Error('"else" tag does not accept any tokens. Found "' + token.match + '" on line ' + line + '.');
  });

  return (stack.length &amp;&amp; stack[stack.length - 1].name === 'if');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.elseif" id="apidoc.module.swig.elseif">module swig.elseif</a></h1>


    <h2>
        <a href="#apidoc.element.swig.elseif.compile" id="apidoc.element.swig.elseif.compile">
        function <span class="apidocSignatureSpan">swig.elseif.</span>compile
        <span class="apidocSignatureSpan">(compiler, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (compiler, args) {
  return '} else if (' + args.join(' ') + ') {\n';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.elseif.parse" id="apidoc.element.swig.elseif.parse">
        function <span class="apidocSignatureSpan">swig.elseif.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser, types, stack)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser, types, stack) {
  var okay = ifparser(str, line, parser, types, stack);
  return okay &amp;&amp; (stack.length &amp;&amp; stack[stack.length - 1].name === 'if');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.extends" id="apidoc.module.swig.extends">module swig.extends</a></h1>




    <h2>
        <a href="#apidoc.element.swig.extends.compile" id="apidoc.element.swig.extends.compile">
        function <span class="apidocSignatureSpan">swig.extends.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.extends.parse" id="apidoc.element.swig.extends.parse">
        function <span class="apidocSignatureSpan">swig.extends.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.filter" id="apidoc.module.swig.filter">module swig.filter</a></h1>




    <h2>
        <a href="#apidoc.element.swig.filter.compile" id="apidoc.element.swig.filter.compile">
        function <span class="apidocSignatureSpan">swig.filter.</span>compile
        <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (compiler, args, content, parents, options, blockName) {
  var filter = args.shift().replace(/\($/, ''),
    val = '(function () {\n' +
      '  var _output = "";\n' +
      compiler(content, parents, options, blockName) +
      '  return _output;\n' +
      '})()';

  if (args[args.length - 1] === ')') {
    args.pop();
  }

  args = (args.length) ? ', ' + args.join('') : '';
  return '_output += _filters["' + filter + '"](' + val + args + ');\n';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filter.parse" id="apidoc.element.swig.filter.parse">
        function <span class="apidocSignatureSpan">swig.filter.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser, types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser, types) {
  var filter;

  function check(filter) {
    if (!filters.hasOwnProperty(filter)) {
      throw new Error('Filter "' + filter + '" does not exist on line ' + line + '.');
    }
  }

  parser.on(types.FUNCTION, function (token) {
    if (!filter) {
      filter = token.match.replace(/\($/, '');
      check(filter);
      this.out.push(token.match);
      this.state.push(token.type);
      return;
    }
    return true;
  });

  parser.on(types.VAR, function (token) {
    if (!filter) {
      filter = token.match;
      check(filter);
      this.out.push(filter);
      return;
    }
    return true;
  });

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.filters" id="apidoc.module.swig.filters">module swig.filters</a></h1>


    <h2>
        <a href="#apidoc.element.swig.filters.addslashes" id="apidoc.element.swig.filters.addslashes">
        function <span class="apidocSignatureSpan">swig.filters.</span>addslashes
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addslashes = function (input) {
  var out = iterateFilter.apply(exports.addslashes, arguments);
  if (out !== undefined) {
    return out;
  }

  return input.replace(/\\/g, '\\\\').replace(/\'/g, "\\'").replace(/\"/g, '\\"');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.capitalize" id="apidoc.element.swig.filters.capitalize">
        function <span class="apidocSignatureSpan">swig.filters.</span>capitalize
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">capitalize = function (input) {
  var out = iterateFilter.apply(exports.capitalize, arguments);
  if (out !== undefined) {
    return out;
  }

  return input.toString().charAt(0).toUpperCase() + input.toString().substr(1).toLowerCase();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.date" id="apidoc.element.swig.filters.date">
        function <span class="apidocSignatureSpan">swig.filters.</span>date
        <span class="apidocSignatureSpan">(input, format, offset, abbr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">date = function (input, format, offset, abbr) {
  var l = format.length,
    date = new dateFormatter.DateZ(input),
    cur,
    i = 0,
    out = '';

  if (offset) {
    date.setTimezoneOffset(offset, abbr);
  }

  for (i; i &lt; l; i += 1) {
    cur = format.charAt(i);
    if (cur === '\\') {
      i += 1;
      out += (i &lt; l) ? format.charAt(i) : cur;
    } else if (dateFormatter.hasOwnProperty(cur)) {
      out += dateFormatter[cur](date, offset, abbr);
    } else {
      out += cur;
    }
  }
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.default" id="apidoc.element.swig.filters.default">
        function <span class="apidocSignatureSpan">swig.filters.</span>default
        <span class="apidocSignatureSpan">(input, def)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">default = function (input, def) {
  return (typeof input !== 'undefined' &amp;&amp; (input || typeof input === 'number')) ? input : def;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  'options': 'Customize Swig\'s Options from a CommonJS-style file',
  'wrap-start': 'Template wrapper beginning for "compile".',
  'wrap-end': 'Template wrapper end for "compile".',
  'method-name': 'Method name to set template to and run from.'
})
.alias('v', 'version')
.alias('o', 'output')
.<span class="apidocCodeKeywordSpan">default</span>('o', 'stdout')
.alias('h', 'help')
.alias('j', 'json')
.alias('c', 'context')
.alias('m', 'minify')
.default('wrap-start', 'var tpl = ')
.default('wrap-end', ';')
.default('method-name', 'tpl')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.e" id="apidoc.element.swig.filters.e">
        function <span class="apidocSignatureSpan">swig.filters.</span>e
        <span class="apidocSignatureSpan">(input, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">e = function (input, type) {
  var out = iterateFilter.apply(exports.escape, arguments),
    inp = input,
    i = 0,
    code;

  if (out !== undefined) {
    return out;
  }

  if (typeof input !== 'string') {
    return input;
  }

  out = '';

  switch (type) {
  case 'js':
    inp = inp.replace(/\\/g, '\\u005C');
    for (i; i &lt; inp.length; i += 1) {
      code = inp.charCodeAt(i);
      if (code &lt; 32) {
        code = code.toString(16).toUpperCase();
        code = (code.length &lt; 2) ? '0' + code : code;
        out += '\\u00' + code;
      } else {
        out += inp[i];
      }
    }
    return out.replace(/&amp;/g, '\\u0026')
      .replace(/&lt;/g, '\\u003C')
      .replace(/&gt;/g, '\\u003E')
      .replace(/\'/g, '\\u0027')
      .replace(/"/g, '\\u0022')
      .replace(/\=/g, '\\u003D')
      .replace(/-/g, '\\u002D')
      .replace(/;/g, '\\u003B');

  default:
    return inp.replace(/&amp;(?!amp;|lt;|gt;|quot;|#39;)/g, '&amp;amp;')
      .replace(/&lt;/g, '&amp;lt;')
      .replace(/&gt;/g, '&amp;gt;')
      .replace(/"/g, '&amp;quot;')
      .replace(/'/g, '&amp;#39;');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.escape" id="apidoc.element.swig.filters.escape">
        function <span class="apidocSignatureSpan">swig.filters.</span>escape
        <span class="apidocSignatureSpan">(input, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escape = function (input, type) {
  var out = iterateFilter.apply(exports.escape, arguments),
    inp = input,
    i = 0,
    code;

  if (out !== undefined) {
    return out;
  }

  if (typeof input !== 'string') {
    return input;
  }

  out = '';

  switch (type) {
  case 'js':
    inp = inp.replace(/\\/g, '\\u005C');
    for (i; i &lt; inp.length; i += 1) {
      code = inp.charCodeAt(i);
      if (code &lt; 32) {
        code = code.toString(16).toUpperCase();
        code = (code.length &lt; 2) ? '0' + code : code;
        out += '\\u00' + code;
      } else {
        out += inp[i];
      }
    }
    return out.replace(/&amp;/g, '\\u0026')
      .replace(/&lt;/g, '\\u003C')
      .replace(/&gt;/g, '\\u003E')
      .replace(/\'/g, '\\u0027')
      .replace(/"/g, '\\u0022')
      .replace(/\=/g, '\\u003D')
      .replace(/-/g, '\\u002D')
      .replace(/;/g, '\\u003B');

  default:
    return inp.replace(/&amp;(?!amp;|lt;|gt;|quot;|#39;)/g, '&amp;amp;')
      .replace(/&lt;/g, '&amp;lt;')
      .replace(/&gt;/g, '&amp;gt;')
      .replace(/"/g, '&amp;quot;')
      .replace(/'/g, '&amp;#39;');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.first" id="apidoc.element.swig.filters.first">
        function <span class="apidocSignatureSpan">swig.filters.</span>first
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">first = function (input) {
  if (typeof input === 'object' &amp;&amp; !utils.isArray(input)) {
    var keys = utils.keys(input);
    return input[keys[0]];
  }

  if (typeof input === 'string') {
    return input.substr(0, 1);
  }

  return input[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.groupBy" id="apidoc.element.swig.filters.groupBy">
        function <span class="apidocSignatureSpan">swig.filters.</span>groupBy
        <span class="apidocSignatureSpan">(input, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBy = function (input, key) {
  if (!utils.isArray(input)) {
    return input;
  }

  var out = {};

  utils.each(input, function (value) {
    if (!value.hasOwnProperty(key)) {
      return;
    }

    var keyname = value[key],
      newVal = utils.extend({}, value);
    delete value[key];

    if (!out[keyname]) {
      out[keyname] = [];
    }

    out[keyname].push(value);
  });

  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.join" id="apidoc.element.swig.filters.join">
        function <span class="apidocSignatureSpan">swig.filters.</span>join
        <span class="apidocSignatureSpan">(input, glue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function (input, glue) {
  if (utils.isArray(input)) {
    return input.join(glue);
  }

  if (typeof input === 'object') {
    var out = [];
    utils.each(input, function (value) {
      out.push(value);
    });
    return out.join(glue);
  }
  return input;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param  {*}  input
 * @param  {string} glue    String value to join items together.
 * @return {string}
 */
exports.join = function (input, glue) {
if (utils.isArray(input)) {
  return input.<span class="apidocCodeKeywordSpan">join</span>(glue);
}

if (typeof input === 'object') {
  var out = [];
  utils.each(input, function (value) {
    out.push(value);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.json" id="apidoc.element.swig.filters.json">
        function <span class="apidocSignatureSpan">swig.filters.</span>json
        <span class="apidocSignatureSpan">(input, indent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (input, indent) {
  return JSON.stringify(input, null, indent || 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.json_encode" id="apidoc.element.swig.filters.json_encode">
        function <span class="apidocSignatureSpan">swig.filters.</span>json_encode
        <span class="apidocSignatureSpan">(input, indent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json_encode = function (input, indent) {
  return JSON.stringify(input, null, indent || 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.last" id="apidoc.element.swig.filters.last">
        function <span class="apidocSignatureSpan">swig.filters.</span>last
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">last = function (input) {
  if (typeof input === 'object' &amp;&amp; !utils.isArray(input)) {
    var keys = utils.keys(input);
    return input[keys[keys.length - 1]];
  }

  if (typeof input === 'string') {
    return input.charAt(input.length - 1);
  }

  return input[input.length - 1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.lower" id="apidoc.element.swig.filters.lower">
        function <span class="apidocSignatureSpan">swig.filters.</span>lower
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lower = function (input) {
  var out = iterateFilter.apply(exports.lower, arguments);
  if (out !== undefined) {
    return out;
  }

  return input.toString().toLowerCase();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.raw" id="apidoc.element.swig.filters.raw">
        function <span class="apidocSignatureSpan">swig.filters.</span>raw
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">raw = function (input) {
  return exports.safe(input);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.replace" id="apidoc.element.swig.filters.replace">
        function <span class="apidocSignatureSpan">swig.filters.</span>replace
        <span class="apidocSignatureSpan">(input, search, replacement, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (input, search, replacement, flags) {
  var r = new RegExp(search, flags);
  return input.replace(r, replacement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.options) {
  swig.setDefaults(require(argv.options));
}

switch (command) {
case 'compile':
  fn = function (file, str) {
var r = swig.precompile(str, { filename: file, locals: ctx }).tpl.toString().<span class="apidocCodeKeywordSpan">replace</span>(&amp;#
x27;anonymous', '');

r = argv['wrap-start'] + r + argv['wrap-end'];

if (argv.m) {
  r = uglify.minify(r, { fromString: true }).code;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.reverse" id="apidoc.element.swig.filters.reverse">
        function <span class="apidocSignatureSpan">swig.filters.</span>reverse
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reverse = function (input) {
  return exports.sort(input, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  switch (typeof input) {
  case 'object':
    out = utils.keys(input).sort();
    break;
  case 'string':
    out = input.split('');
    if (reverse) {
      return out.<span class="apidocCodeKeywordSpan">reverse</span>().join('');
    }
    return out.sort().join('');
  }
}

if (out &amp;&amp; reverse) {
  return out.reverse();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.safe" id="apidoc.element.swig.filters.safe">
        function <span class="apidocSignatureSpan">swig.filters.</span>safe
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">safe = function (input) {
  // This is a magic filter. Its logic is hard-coded into Swig's parser.
  return input;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 return input.toString().toLowerCase();
};

/**
* Deprecated in favor of &lt;a href="#safe"&gt;safe&lt;/a&gt;.
*/
exports.raw = function (input) {
 return exports.<span class="apidocCodeKeywordSpan">safe</span>(input);
};
exports.raw.safe = true;

/**
* Returns a new string with the matched search pattern replaced by the given replacement string. Uses JavaScript's built-in
 String.replace() method.
*
* @example
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.sort" id="apidoc.element.swig.filters.sort">
        function <span class="apidocSignatureSpan">swig.filters.</span>sort
        <span class="apidocSignatureSpan">(input, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function (input, reverse) {
  var out;
  if (utils.isArray(input)) {
    out = input.sort();
  } else {
    switch (typeof input) {
    case 'object':
      out = utils.keys(input).sort();
      break;
    case 'string':
      out = input.split('');
      if (reverse) {
        return out.reverse().join('');
      }
      return out.sort().join('');
    }
  }

  if (out &amp;&amp; reverse) {
    return out.reverse();
  }

  return out || input;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* {{ val|reverse }}
* // =&gt; 3,2,1
*
* @param  {array}  input
* @return {array}        Reversed array. The original input object is returned if it was not an array.
*/
exports.reverse = function (input) {
 return exports.<span class="apidocCodeKeywordSpan">sort</span>(input, true);
};

/**
* Forces the input to not be auto-escaped. Use this only on content that you know is safe to be rendered on your page.
*
* @example
* // my_var = "&lt;p&gt;Stuff&lt;/p&gt;";
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.striptags" id="apidoc.element.swig.filters.striptags">
        function <span class="apidocSignatureSpan">swig.filters.</span>striptags
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">striptags = function (input) {
  var out = iterateFilter.apply(exports.striptags, arguments);
  if (out !== undefined) {
    return out;
  }

  return input.toString().replace(/(&lt;([^&gt;]+)&gt;)/ig, '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.title" id="apidoc.element.swig.filters.title">
        function <span class="apidocSignatureSpan">swig.filters.</span>title
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">title = function (input) {
  var out = iterateFilter.apply(exports.title, arguments);
  if (out !== undefined) {
    return out;
  }

  return input.toString().replace(/\w\S*/g, function (str) {
    return str.charAt(0).toUpperCase() + str.substr(1).toLowerCase();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.uniq" id="apidoc.element.swig.filters.uniq">
        function <span class="apidocSignatureSpan">swig.filters.</span>uniq
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uniq = function (input) {
  var result;

  if (!input || !utils.isArray(input)) {
    return '';
  }

  result = [];
  utils.each(input, function (v) {
    if (result.indexOf(v) === -1) {
      result.push(v);
    }
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.upper" id="apidoc.element.swig.filters.upper">
        function <span class="apidocSignatureSpan">swig.filters.</span>upper
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">upper = function (input) {
  var out = iterateFilter.apply(exports.upper, arguments);
  if (out !== undefined) {
    return out;
  }

  return input.toString().toUpperCase();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.url_decode" id="apidoc.element.swig.filters.url_decode">
        function <span class="apidocSignatureSpan">swig.filters.</span>url_decode
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">url_decode = function (input) {
  var out = iterateFilter.apply(exports.url_decode, arguments);
  if (out !== undefined) {
    return out;
  }
  return decodeURIComponent(input);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.filters.url_encode" id="apidoc.element.swig.filters.url_encode">
        function <span class="apidocSignatureSpan">swig.filters.</span>url_encode
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">url_encode = function (input) {
  var out = iterateFilter.apply(exports.url_encode, arguments);
  if (out !== undefined) {
    return out;
  }
  return encodeURIComponent(input);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.for" id="apidoc.module.swig.for">module swig.for</a></h1>




    <h2>
        <a href="#apidoc.element.swig.for.compile" id="apidoc.element.swig.for.compile">
        function <span class="apidocSignatureSpan">swig.for.</span>compile
        <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (compiler, args, content, parents, options, blockName) {
  var val = args.shift(),
    key = '__k',
    ctxloopcache = (ctx + '__loopcache' + Math.random()).replace(/\./g, ''),
    last;

  if (args[0] &amp;&amp; args[0] === ',') {
    args.shift();
    key = val;
    val = args.shift();
  }

  last = args.join('');

  return [
    '(function () {\n',
    '  var __l = ' + last + ', __len = (_utils.isArray(__l) || typeof __l === "string") ? __l.length : _utils.keys(__l).length;\
n',
    '  if (!__l) { return; }\n',
    '    var ' + ctxloopcache + ' = { loop: ' + ctxloop + ', ' + val + ': ' + ctx + val + ', ' + key + ': ' + ctx + key + ' };\n
',
    '    ' + ctxloop + ' = { first: false, index: 1, index0: 0, revindex: __len, revindex0: __len - 1, length: __len, last: false
 };\n',
    '  _utils.each(__l, function (' + val + ', ' + key + ') {\n',
    '    ' + ctx + val + ' = ' + val + ';\n',
    '    ' + ctx + key + ' = ' + key + ';\n',
    '    ' + ctxloop + '.key = ' + key + ';\n',
    '    ' + ctxloop + '.first = (' + ctxloop + '.index0 === 0);\n',
    '    ' + ctxloop + '.last = (' + ctxloop + '.revindex0 === 0);\n',
    '    ' + compiler(content, parents, options, blockName),
    '    ' + ctxloop + '.index += 1; ' + ctxloop + '.index0 += 1; ' + ctxloop + '.revindex -= 1; ' + ctxloop + '.revindex0 -= 1;\n',
    '  });\n',
    '  ' + ctxloop + ' = ' + ctxloopcache + '.loop;\n',
    '  ' + ctx + val + ' = ' + ctxloopcache + '.' + val + ';\n',
    '  ' + ctx + key + ' = ' + ctxloopcache + '.' + key + ';\n',
    '  ' + ctxloopcache + ' = undefined;\n',
    '})();\n'
  ].join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.for.parse" id="apidoc.element.swig.for.parse">
        function <span class="apidocSignatureSpan">swig.for.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser, types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser, types) {
  var firstVar, ready;

  parser.on(types.NUMBER, function (token) {
    var lastState = this.state.length ? this.state[this.state.length - 1] : null;
    if (!ready ||
        (lastState !== types.ARRAYOPEN &amp;&amp;
          lastState !== types.CURLYOPEN &amp;&amp;
          lastState !== types.CURLYCLOSE &amp;&amp;
          lastState !== types.FUNCTION &amp;&amp;
          lastState !== types.FILTER)
        ) {
      throw new Error('Unexpected number "' + token.match + '" on line ' + line + '.');
    }
    return true;
  });

  parser.on(types.VAR, function (token) {
    if (ready &amp;&amp; firstVar) {
      return true;
    }

    if (!this.out.length) {
      firstVar = true;
    }

    this.out.push(token.match);
  });

  parser.on(types.COMMA, function (token) {
    if (firstVar &amp;&amp; this.prevToken.type === types.VAR) {
      this.out.push(token.match);
      return;
    }

    return true;
  });

  parser.on(types.COMPARATOR, function (token) {
    if (token.match !== 'in' || !firstVar) {
      throw new Error('Unexpected token "' + token.match + '" on line ' + line + '.');
    }
    ready = true;
    this.filterApplyIdx.push(this.out.length);
  });

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.if" id="apidoc.module.swig.if">module swig.if</a></h1>




    <h2>
        <a href="#apidoc.element.swig.if.compile" id="apidoc.element.swig.if.compile">
        function <span class="apidocSignatureSpan">swig.if.</span>compile
        <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (compiler, args, content, parents, options, blockName) {
  return 'if (' + args.join(' ') + ') { \n' +
    compiler(content, parents, options, blockName) + '\n' +
    '}';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.if.parse" id="apidoc.element.swig.if.parse">
        function <span class="apidocSignatureSpan">swig.if.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser, types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser, types) {
  if (typeof str === "undefined") {
    throw new Error('No conditional statement provided on line ' + line + '.');
  }

  parser.on(types.COMPARATOR, function (token) {
    if (this.isLast) {
      throw new Error('Unexpected logic "' + token.match + '" on line ' + line + '.');
    }
    if (this.prevToken.type === types.NOT) {
      throw new Error('Attempted logic "not ' + token.match + '" on line ' + line + '. Use !(foo ' + token.match + ') instead.');
    }
    this.out.push(token.match);
    this.filterApplyIdx.push(this.out.length);
  });

  parser.on(types.NOT, function (token) {
    if (this.isLast) {
      throw new Error('Unexpected logic "' + token.match + '" on line ' + line + '.');
    }
    this.out.push(token.match);
  });

  parser.on(types.BOOL, function (token) {
    this.out.push(token.match);
  });

  parser.on(types.LOGIC, function (token) {
    if (!this.out.length || this.isLast) {
      throw new Error('Unexpected logic "' + token.match + '" on line ' + line + '.');
    }
    this.out.push(token.match);
    this.filterApplyIdx.pop();
  });

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.import" id="apidoc.module.swig.import">module swig.import</a></h1>




    <h2>
        <a href="#apidoc.element.swig.import.compile" id="apidoc.element.swig.import.compile">
        function <span class="apidocSignatureSpan">swig.import.</span>compile
        <span class="apidocSignatureSpan">(compiler, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (compiler, args) {
  var ctx = args.pop(),
    out = '_ctx.' + ctx + ' = {};\n  var _output = "";\n',
    replacements = utils.map(args, function (arg) {
      return {
        ex: new RegExp('_ctx.' + arg.name, 'g'),
        re: '_ctx.' + ctx + '.' + arg.name
      };
    });

  // Replace all occurrences of all macros in this file with
  // proper namespaced definitions and calls
  utils.each(args, function (arg) {
    var c = arg.compiled;
    utils.each(replacements, function (re) {
      c = c.replace(re.ex, re.re);
    });
    out += c;
  });

  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.import.parse" id="apidoc.element.swig.import.parse">
        function <span class="apidocSignatureSpan">swig.import.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser, types, stack, opts, swig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser, types, stack, opts, swig) {
  var compiler = require('../parser').compile,
    parseOpts = { resolveFrom: opts.filename },
    compileOpts = utils.extend({}, opts, parseOpts),
    tokens,
    ctx;

  parser.on(types.STRING, function (token) {
    var self = this;
    if (!tokens) {
      tokens = swig.parseFile(token.match.replace(/^("|')|("|')$/g, ''), parseOpts).tokens;
      utils.each(tokens, function (token) {
        var out = '',
          macroName;
        if (!token || token.name !== 'macro' || !token.compile) {
          return;
        }
        macroName = token.args[0];
        out += token.compile(compiler, token.args, token.content, [], compileOpts) + '\n';
        self.out.push({compiled: out, name: macroName});
      });
      return;
    }

    throw new Error('Unexpected string ' + token.match + ' on line ' + line + '.');
  });

  parser.on(types.VAR, function (token) {
    var self = this;
    if (!tokens || ctx) {
      throw new Error('Unexpected variable "' + token.match + '" on line ' + line + '.');
    }

    if (token.match === 'as') {
      return;
    }

    ctx = token.match;
    self.out.push(ctx);
    return false;
  });

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.include" id="apidoc.module.swig.include">module swig.include</a></h1>


    <h2>
        <a href="#apidoc.element.swig.include.compile" id="apidoc.element.swig.include.compile">
        function <span class="apidocSignatureSpan">swig.include.</span>compile
        <span class="apidocSignatureSpan">(compiler, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (compiler, args) {
  var file = args.shift(),
    onlyIdx = args.indexOf(only),
    onlyCtx = onlyIdx !== -1 ? args.splice(onlyIdx, 1) : false,
    parentFile = (args.pop() || '').replace(/\\/g, '\\\\'),
    ignore = args[args.length - 1] === missing ? (args.pop()) : false,
    w = args.join('');

  return (ignore ? '  try {\n' : '') +
    '_output += _swig.compileFile(' + file + ', {' +
    'resolveFrom: "' + parentFile + '"' +
    '})(' +
    ((onlyCtx &amp;&amp; w) ? w : (!w ? '_ctx' : '_utils.extend({}, _ctx, ' + w + ')')) +
    ');\n' +
    (ignore ? '} catch (e) {}\n' : '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.include.parse" id="apidoc.element.swig.include.parse">
        function <span class="apidocSignatureSpan">swig.include.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser, types, stack, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser, types, stack, opts) {
  var file, w;
  parser.on(types.STRING, function (token) {
    if (!file) {
      file = token.match;
      this.out.push(file);
      return;
    }

    return true;
  });

  parser.on(types.VAR, function (token) {
    if (!file) {
      file = token.match;
      return true;
    }

    if (!w &amp;&amp; token.match === 'with') {
      w = true;
      return;
    }

    if (w &amp;&amp; token.match === only &amp;&amp; this.prevToken.match !== 'with') {
      this.out.push(token.match);
      return;
    }

    if (token.match === ignore) {
      return false;
    }

    if (token.match === missing) {
      if (this.prevToken.match !== ignore) {
        throw new Error('Unexpected token "' + missing + '" on line ' + line + '.');
      }
      this.out.push(token.match);
      return false;
    }

    if (this.prevToken.match === ignore) {
      throw new Error('Expected "' + missing + '" on line ' + line + ' but found "' + token.match + '".');
    }

    return true;
  });

  parser.on('end', function () {
    this.out.push(opts.filename || null);
  });

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.lexer" id="apidoc.module.swig.lexer">module swig.lexer</a></h1>


    <h2>
        <a href="#apidoc.element.swig.lexer.read" id="apidoc.element.swig.lexer.read">
        function <span class="apidocSignatureSpan">swig.lexer.</span>read
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (str) {
  var offset = 0,
    tokens = [],
    substr,
    match;
  while (offset &lt; str.length) {
    substr = str.substring(offset);
    match = reader(substr);
    offset += match.length;
    tokens.push(match);
  }
  return tokens;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Parse a variable.
   * @param  {string} str  String contents of the variable, between &lt;i&gt;{{&lt;/i&gt; and &lt;i&gt;}}&lt;/i&gt;
;
   * @param  {number} line The line number that this variable starts on.
   * @return {VarToken}      Parsed variable token object.
   * @private
   */
  function parseVariable(str, line) {
var tokens = lexer.<span class="apidocCodeKeywordSpan">read</span>(utils.strip(str)),
  parser,
  out;

parser = new TokenParser(tokens, filters, escape, line, opts.filename);
out = parser.parse().join('');

if (parser.state.length) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.loaders" id="apidoc.module.swig.loaders">module swig.loaders</a></h1>


    <h2>
        <a href="#apidoc.element.swig.loaders.fs" id="apidoc.element.swig.loaders.fs">
        function <span class="apidocSignatureSpan">swig.loaders.</span>fs
        <span class="apidocSignatureSpan">(basepath, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fs = function (basepath, encoding) {
  var ret = {};

  encoding = encoding || 'utf8';
  basepath = (basepath) ? path.normalize(basepath) : null;

<span class="apidocCodeCommentSpan">  /**
   * Resolves &lt;var&gt;to&lt;/var&gt; to an absolute path or unique identifier. This is used for building correct, normalized, and absolute
 paths to a given template.
   * @alias resolve
   * @param  {string} to        Non-absolute identifier or pathname to a file.
   * @param  {string} [from]    If given, should attempt to find the &lt;var&gt;to&lt;/var&gt; path in relation to this given, known path.
   * @return {string}
   */
</span>  ret.resolve = function (to, from) {
    if (basepath) {
      from = basepath;
    } else {
      from = (from) ? path.dirname(from) : process.cwd();
    }
    return path.resolve(from, to);
  };

  /**
   * Loads a single template. Given a unique &lt;var&gt;identifier&lt;/var&gt; found by the &lt;var&gt;resolve&lt;/var&gt; method this should return the
 given template.
   * @alias load
   * @param  {string}   identifier  Unique identifier of a template (possibly an absolute path).
   * @param  {function} [cb]        Asynchronous callback function. If not provided, this method should run synchronously.
   * @return {string}               Template source string.
   */
  ret.load = function (identifier, cb) {
    if (!fs || (cb &amp;&amp; !fs.readFile) || !fs.readFileSync) {
      throw new Error('Unable to find file ' + identifier + ' because there is no filesystem to read from.');
    }

    identifier = ret.resolve(identifier);

    if (cb) {
      fs.readFile(identifier, encoding, cb);
      return;
    }
    return fs.readFileSync(identifier, encoding);
  };

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var process=require("__browserify_process");var fs = require('fs'),
  path = require('path');

/**
 * Loads templates from the file system.
 * @alias swig.loaders.fs
 * @example
 * swig.setDefaults({ loader: swig.loaders.<span class="apidocCodeKeywordSpan">fs</span>() });
 * @example
 * // Load Templates from a specific directory (does not require using relative paths in your templates)
 * swig.setDefaults({ loader: swig.loaders.fs(__dirname + '/templates' )});
 * @param {string}   [basepath='']     Path to the templates as string. Assigning this value allows you to use semi-absolute
 paths to templates instead of relative paths.
 * @param {string}   [encoding='utf8']   Template encoding
 */
module.exports = function (basepath, encoding) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.loaders.memory" id="apidoc.element.swig.loaders.memory">
        function <span class="apidocSignatureSpan">swig.loaders.</span>memory
        <span class="apidocSignatureSpan">(mapping, basepath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memory = function (mapping, basepath) {
  var ret = {};

  basepath = (basepath) ? path.normalize(basepath) : null;

<span class="apidocCodeCommentSpan">  /**
   * Resolves &lt;var&gt;to&lt;/var&gt; to an absolute path or unique identifier. This is used for building correct, normalized, and absolute
 paths to a given template.
   * @alias resolve
   * @param  {string} to        Non-absolute identifier or pathname to a file.
   * @param  {string} [from]    If given, should attempt to find the &lt;var&gt;to&lt;/var&gt; path in relation to this given, known path.
   * @return {string}
   */
</span>  ret.resolve = function (to, from) {
    if (basepath) {
      from = basepath;
    } else {
      from = (from) ? path.dirname(from) : '/';
    }
    return path.resolve(from, to);
  };

  /**
   * Loads a single template. Given a unique &lt;var&gt;identifier&lt;/var&gt; found by the &lt;var&gt;resolve&lt;/var&gt; method this should return the
 given template.
   * @alias load
   * @param  {string}   identifier  Unique identifier of a template (possibly an absolute path).
   * @param  {function} [cb]        Asynchronous callback function. If not provided, this method should run synchronously.
   * @return {string}               Template source string.
   */
  ret.load = function (pathname, cb) {
    var src, paths;

    paths = [pathname, pathname.replace(/^(\/|\\)/, '')];

    src = mapping[paths[0]] || mapping[paths[1]];
    if (!src) {
      utils.throwError('Unable to find template "' + pathname + '".');
    }

    if (cb) {
      cb(null, src);
      return;
    }
    return src;
  };

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Loads templates from a provided object mapping.
 * @alias swig.loaders.memory
 * @example
 * var templates = {
 *   "layout": "{% block content %}{% endblock %}",
 *   "home.html": "{% extends 'layout.html' %}{% block content %}...{% endblock %}"
 * };
 * swig.setDefaults({ loader: swig.loaders.<span class="apidocCodeKeywordSpan">memory</span>(templates) });
 *
 * @param {object} mapping Hash object with template paths as keys and template sources as values.
 * @param {string} [basepath] Path to the templates as string. Assigning this value allows you to use semi-absolute paths to templates
 instead of relative paths.
 */
module.exports = function (mapping, basepath) {
var ret = {};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.macro" id="apidoc.module.swig.macro">module swig.macro</a></h1>






    <h2>
        <a href="#apidoc.element.swig.macro.compile" id="apidoc.element.swig.macro.compile">
        function <span class="apidocSignatureSpan">swig.macro.</span>compile
        <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (compiler, args, content, parents, options, blockName) {
  var fnName = args.shift();

  return '_ctx.' + fnName + ' = function (' + args.join('') + ') {\n' +
    '  var _output = "",\n' +
    '    __ctx = _utils.extend({}, _ctx);\n' +
    '  _utils.each(_ctx, function (v, k) {\n' +
    '    if (["' + args.join('","') + '"].indexOf(k) !== -1) { delete _ctx[k]; }\n' +
    '  });\n' +
    compiler(content, parents, options, blockName) + '\n' +
    ' _ctx = _utils.extend(_ctx, __ctx);\n' +
    '  return _output;\n' +
    '};\n' +
    '_ctx.' + fnName + '.safe = true;\n';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.macro.parse" id="apidoc.element.swig.macro.parse">
        function <span class="apidocSignatureSpan">swig.macro.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser, types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser, types) {
  var name;

  parser.on(types.VAR, function (token) {
    if (token.match.indexOf('.') !== -1) {
      throw new Error('Unexpected dot in macro argument "' + token.match + '" on line ' + line + '.');
    }
    this.out.push(token.match);
  });

  parser.on(types.FUNCTION, function (token) {
    if (!name) {
      name = token.match;
      this.out.push(name);
      this.state.push(types.FUNCTION);
    }
  });

  parser.on(types.FUNCTIONEMPTY, function (token) {
    if (!name) {
      name = token.match;
      this.out.push(name);
    }
  });

  parser.on(types.PARENCLOSE, function () {
    if (this.isLast) {
      return;
    }
    throw new Error('Unexpected parenthesis close on line ' + line + '.');
  });

  parser.on(types.COMMA, function () {
    return true;
  });

  parser.on('*', function () {
    return;
  });

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.parent" id="apidoc.module.swig.parent">module swig.parent</a></h1>


    <h2>
        <a href="#apidoc.element.swig.parent.compile" id="apidoc.element.swig.parent.compile">
        function <span class="apidocSignatureSpan">swig.parent.</span>compile
        <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (compiler, args, content, parents, options, blockName) {
  if (!parents || !parents.length) {
    return '';
  }

  var parentFile = args[0],
    breaker = true,
    l = parents.length,
    i = 0,
    parent,
    block;

  for (i; i &lt; l; i += 1) {
    parent = parents[i];
    if (!parent.blocks || !parent.blocks.hasOwnProperty(blockName)) {
      continue;
    }
    // Silly JSLint "Strange Loop" requires return to be in a conditional
    if (breaker &amp;&amp; parentFile !== parent.name) {
      block = parent.blocks[blockName];
      return block.compile(compiler, [blockName], block.content, parents.slice(i + 1), options) + '\n';
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.parent.parse" id="apidoc.element.swig.parent.parse">
        function <span class="apidocSignatureSpan">swig.parent.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser, types, stack, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser, types, stack, opts) {
  parser.on('*', function (token) {
    throw new Error('Unexpected argument "' + token.match + '" on line ' + line + '.');
  });

  parser.on('end', function () {
    this.out.push(opts.filename);
  });

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.parser" id="apidoc.module.swig.parser">module swig.parser</a></h1>


    <h2>
        <a href="#apidoc.element.swig.parser.compile" id="apidoc.element.swig.parser.compile">
        function <span class="apidocSignatureSpan">swig.parser.</span>compile
        <span class="apidocSignatureSpan">(template, parents, options, blockName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (template, parents, options, blockName) {
  var out = '',
    tokens = utils.isArray(template) ? template : template.tokens;

  utils.each(tokens, function (token) {
    var o;
    if (typeof token === 'string') {
      out += '_output += "' + token.replace(/\\/g, '\\\\').replace(/\n|\r/g, '\\n').replace(/"/g, '\\"') + '";\n';
      return;
    }

<span class="apidocCodeCommentSpan">    /**
     * Compile callback for VarToken and TagToken objects.
     * @callback compile
     *
     * @example
     * exports.compile = function (compiler, args, content, parents, options, blockName) {
     *   if (args[0] === 'foo') {
     *     return compiler(content, parents, options, blockName) + '\n';
     *   }
     *   return '_output += "fallback";\n';
     * };
     *
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
</span>    o = token.compile(exports.compile, token.args ? token.args.slice(0) : [], token.content ? token.content.slice(0) : [], parents
, options, blockName);
    out += o || '';
  });

  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.parser.parse" id="apidoc.element.swig.parser.parse">
        function <span class="apidocSignatureSpan">swig.parser.</span>parse
        <span class="apidocSignatureSpan">(swig, source, opts, tags, filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (swig, source, opts, tags, filters) {
  source = source.replace(/\r\n/g, '\n');
  var escape = opts.autoescape,
    tagOpen = opts.tagControls[0],
    tagClose = opts.tagControls[1],
    varOpen = opts.varControls[0],
    varClose = opts.varControls[1],
    escapedTagOpen = escapeRegExp(tagOpen),
    escapedTagClose = escapeRegExp(tagClose),
    escapedVarOpen = escapeRegExp(varOpen),
    escapedVarClose = escapeRegExp(varClose),
    tagStrip = new RegExp('^' + escapedTagOpen + '-?\\s*-?|-?\\s*-?' + escapedTagClose + '$', 'g'),
    tagStripBefore = new RegExp('^' + escapedTagOpen + '-'),
    tagStripAfter = new RegExp('-' + escapedTagClose + '$'),
    varStrip = new RegExp('^' + escapedVarOpen + '-?\\s*-?|-?\\s*-?' + escapedVarClose + '$', 'g'),
    varStripBefore = new RegExp('^' + escapedVarOpen + '-'),
    varStripAfter = new RegExp('-' + escapedVarClose + '$'),
    cmtOpen = opts.cmtControls[0],
    cmtClose = opts.cmtControls[1],
    anyChar = '[\\s\\S]*?',
    // Split the template source based on variable, tag, and comment blocks
    // /(\{%[\s\S]*?%\}|\{\{[\s\S]*?\}\}|\{#[\s\S]*?#\})/
    splitter = new RegExp(
      '(' +
        escapedTagOpen + anyChar + escapedTagClose + '|' +
        escapedVarOpen + anyChar + escapedVarClose + '|' +
        escapeRegExp(cmtOpen) + anyChar + escapeRegExp(cmtClose) +
        ')'
    ),
    line = 1,
    stack = [],
    parent = null,
    tokens = [],
    blocks = {},
    inRaw = false,
    stripNext;

<span class="apidocCodeCommentSpan">  /**
   * Parse a variable.
   * @param  {string} str  String contents of the variable, between &lt;i&gt;{{&lt;/i&gt; and &lt;i&gt;}}&lt;/i&gt;
   * @param  {number} line The line number that this variable starts on.
   * @return {VarToken}      Parsed variable token object.
   * @private
   */
</span>  function parseVariable(str, line) {
    var tokens = lexer.read(utils.strip(str)),
      parser,
      out;

    parser = new TokenParser(tokens, filters, escape, line, opts.filename);
    out = parser.parse().join('');

    if (parser.state.length) {
      utils.throwError('Unable to parse "' + str + '"', line, opts.filename);
    }

    /**
     * A parsed variable token.
     * @typedef {object} VarToken
     * @property {function} compile Method for compiling this token.
     */
    return {
      compile: function () {
        return '_output += ' + out + ';\n';
      }
    };
  }
  exports.parseVariable = parseVariable;

  /**
   * Parse a tag.
   * @param  {string} str  String contents of the tag, between &lt;i&gt;{%&lt;/i&gt; and &lt;i&gt;%}&lt;/i&gt;
   * @param  {number} line The line number that this tag starts on.
   * @return {TagToken}      Parsed token object.
   * @private
   */
  function parseTag(str, line) {
    var tokens, parser, chunks, tagName, tag, args, last;

    if (utils.startsWith(str, 'end')) {
      last = stack[stack.length - 1];
      if (last &amp;&amp; last.name === str.split(/\s+/)[0].replace(/^end/, '') &amp;&amp; last.ends) {
        switch (last.name) {
        case 'autoescape':
          escape = opts.autoescape;
          break;
        case 'raw':
          inRaw = false;
          break;
        }
        stack.pop();
        return;
      }

      if (!inRaw) {
        utils.throwError('Unexpected end of tag "' + str.replace(/^end/, '') + '"', line, opts.filename);
      }
    }

    if (inRaw) {
      return;
    }

    chunks = str.split(/\s+(.+)?/);
    tagName = chunks.shift();

    if (!tags.hasOwnProperty(tagName)) {
      utils.throwError('Unexpected tag "' + str + '"', line, opts.filename);
    }

    tokens = lexer.read(utils.strip(chunks.join(' ')));
    parser = new TokenParser(tokens, filters, false, line, opts.filename);
    tag = tags[tagName];

    /**
     * Define custom parsing methods for your tag.
     * @callback parse
     *
     * @example
     * exports.parse = function (str, line, parser, types, options, swig) {
     *   parser.on('start', function () {
     *     // ...
     *   });
     *   parser.on(types.STRING, function (token) {
     *     // ...
     *   });
     * };
     *
     * @param {string} str The full token string of the tag.
     * @param {number} line ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.raw" id="apidoc.module.swig.raw">module swig.raw</a></h1>




    <h2>
        <a href="#apidoc.element.swig.raw.compile" id="apidoc.element.swig.raw.compile">
        function <span class="apidocSignatureSpan">swig.raw.</span>compile
        <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (compiler, args, content, parents, options, blockName) {
  return compiler(content, parents, options, blockName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.raw.parse" id="apidoc.element.swig.raw.parse">
        function <span class="apidocSignatureSpan">swig.raw.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser) {
  parser.on('*', function (token) {
    throw new Error('Unexpected token "' + token.match + '" in raw tag on line ' + line + '.');
  });
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.set" id="apidoc.module.swig.set">module swig.set</a></h1>




    <h2>
        <a href="#apidoc.element.swig.set.compile" id="apidoc.element.swig.set.compile">
        function <span class="apidocSignatureSpan">swig.set.</span>compile
        <span class="apidocSignatureSpan">(compiler, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (compiler, args) {
  return args.join(' ') + ';\n';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.set.parse" id="apidoc.element.swig.set.parse">
        function <span class="apidocSignatureSpan">swig.set.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser, types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser, types) {
  var nameSet = '',
    propertyName;

  parser.on(types.VAR, function (token) {
    if (propertyName) {
      // Tell the parser where to find the variable
      propertyName += '_ctx.' + token.match;
      return;
    }

    if (!parser.out.length) {
      nameSet += token.match;
      return;
    }

    return true;
  });

  parser.on(types.BRACKETOPEN, function (token) {
    if (!propertyName &amp;&amp; !this.out.length) {
      propertyName = token.match;
      return;
    }

    return true;
  });

  parser.on(types.STRING, function (token) {
    if (propertyName &amp;&amp; !this.out.length) {
      propertyName += token.match;
      return;
    }

    return true;
  });

  parser.on(types.BRACKETCLOSE, function (token) {
    if (propertyName &amp;&amp; !this.out.length) {
      nameSet += propertyName + token.match;
      propertyName = undefined;
      return;
    }

    return true;
  });

  parser.on(types.DOTKEY, function (token) {
    if (!propertyName &amp;&amp; !nameSet) {
      return true;
    }
    nameSet += '.' + token.match;
    return;
  });

  parser.on(types.ASSIGNMENT, function (token) {
    if (this.out.length || !nameSet) {
      throw new Error('Unexpected assignment "' + token.match + '" on line ' + line + '.');
    }

    this.out.push(
      // Prevent the set from spilling into global scope
      '_ctx.' + nameSet
    );
    this.out.push(token.match);
    this.filterApplyIdx.push(this.out.length);
  });

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.spaceless" id="apidoc.module.swig.spaceless">module swig.spaceless</a></h1>




    <h2>
        <a href="#apidoc.element.swig.spaceless.compile" id="apidoc.element.swig.spaceless.compile">
        function <span class="apidocSignatureSpan">swig.spaceless.</span>compile
        <span class="apidocSignatureSpan">(compiler, args, content, parents, options, blockName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (compiler, args, content, parents, options, blockName) {
  function stripWhitespace(tokens) {
    return utils.map(tokens, function (token) {
      if (token.content || typeof token !== 'string') {
        token.content = stripWhitespace(token.content);
        return token;
      }

      return token.replace(/^\s+/, '')
        .replace(/&gt;\s+&lt;/g, '&gt;&lt;')
        .replace(/\s+$/, '');
    });
  }

  return compiler(stripWhitespace(content), parents, options, blockName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.spaceless.parse" id="apidoc.element.swig.spaceless.parse">
        function <span class="apidocSignatureSpan">swig.spaceless.</span>parse
        <span class="apidocSignatureSpan">(str, line, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, line, parser) {
  parser.on('*', function (token) {
    throw new Error('Unexpected token "' + token.match + '" on line ' + line + '.');
  });

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.v) {
console.log(require('../package').version);
process.exit(0);
}

// Pull in any context data provided
if (argv.j) {
ctx = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(argv.j, 'utf8'));
} else if (argv.c) {
ctx = require(argv.c);
}

if (argv.o !== 'stdout') {
argv.o += '/';
argv.o = path.normalize(argv.o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.swig" id="apidoc.module.swig.swig">module swig.swig</a></h1>


    <h2>
        <a href="#apidoc.element.swig.swig.Swig" id="apidoc.element.swig.swig.Swig">
        function <span class="apidocSignatureSpan">swig.swig.</span>Swig
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Swig = function (opts) {
  validateOptions(opts);
  this.options = utils.extend({}, defaultOptions, opts || {});
  this.cache = {};
  this.extensions = {};
  var self = this,
    tags = _tags,
    filters = _filters;

<span class="apidocCodeCommentSpan">  /**
   * Get combined locals context.
   * @param  {?SwigOpts} [options] Swig options object.
   * @return {object}         Locals context.
   * @private
   */
</span>  function getLocals(options) {
    if (!options || !options.locals) {
      return self.options.locals;
    }

    return utils.extend({}, self.options.locals, options.locals);
  }

  /**
   * Determine whether caching is enabled via the options provided and/or defaults
   * @param  {SwigOpts} [options={}] Swig Options Object
   * @return {boolean}
   * @private
   */
  function shouldCache(options) {
    options = options || {};
    return (options.hasOwnProperty('cache') &amp;&amp; !options.cache) || !self.options.cache;
  }

  /**
   * Get compiled template from the cache.
   * @param  {string} key           Name of template.
   * @return {object|undefined}     Template function and tokens.
   * @private
   */
  function cacheGet(key, options) {
    if (shouldCache(options)) {
      return;
    }

    if (self.options.cache === 'memory') {
      return self.cache[key];
    }

    return self.options.cache.get(key);
  }

  /**
   * Store a template in the cache.
   * @param  {string} key Name of template.
   * @param  {object} val Template function and tokens.
   * @return {undefined}
   * @private
   */
  function cacheSet(key, options, val) {
    if (shouldCache(options)) {
      return;
    }

    if (self.options.cache === 'memory') {
      self.cache[key] = val;
      return;
    }

    self.options.cache.set(key, val);
  }

  /**
   * Clears the in-memory template cache.
   *
   * @example
   * swig.invalidateCache();
   *
   * @return {undefined}
   */
  this.invalidateCache = function () {
    if (self.options.cache === 'memory') {
      self.cache = {};
    }
  };

  /**
   * Add a custom filter for swig variables.
   *
   * @example
   * function replaceMs(input) { return input.replace(/m/g, 'f'); }
   * swig.setFilter('replaceMs', replaceMs);
   * // =&gt; {{ "onomatopoeia"|replaceMs }}
   * // =&gt; onofatopeia
   *
   * @param {string}    name    Name of filter, used in templates. &lt;strong&gt;Will&lt;/strong&gt; overwrite previously defined filters, if
 using the same name.
   * @param {function}  method  Function that acts against the input. See &lt;a href="/docs/filters/#custom"&gt;Custom Filters&lt;/a&gt; for
 more information.
   * @return {undefined}
   */
  this.setFilter = function (name, method) {
    if (typeof method !== "function") {
      throw new Error('Filter "' + name + '" is not a valid function.');
    }
    filters[name] = method;
  };

  /**
   * Add a custom tag. To expose your own extensions to compiled template code, see &lt;code data-language="js"&gt;swig.setExtension&lt;/
code&gt;.
   *
   * For a more in-depth explanation of writing custom tags, see &lt;a href="../extending/#tags"&gt;Custom Tags&lt;/a&gt;.
   *
   * @example
   * var tacotag = require('./tacotag');
   * swig.setTag('tacos', tacotag.parse, tacotag.compile, tacotag.ends, tacotag.blockLevel);
   * // =&gt; {% tacos %}Make this be tacos.{% endtacos %}
   * // =&gt; Tacos tacos tacos tacos.
   *
   * @param  {string} name      Tag name.
   * @param  {function} parse   Method for parsing tokens.
   * @param  {function} compile Method for compiling renderable output.
   * @param  {boolean} [ends=false]     Whether or not this tag requires an &lt;i&gt;end&lt;/i&gt; tag.
   * @param  {boolean} [blockLevel=false] If false, this tag will not be compiled outside of &lt;code&gt;block&lt;/code&gt; tags when extending
 a parent template.
   * @return {undefined}
   */
  this.setTag = function (name, parse, compile, ends, blockLevel) {
    if (typeof parse !== 'function') {
      throw new Error('Tag "' + name + '" parse method is not a valid function.');
    }

    if (typeof compile !== 'function') {
      throw new Error('Tag "' + name + '" compile method is not a valid function.');
    }

    tags[name] = {
      parse: parse,
      compile: compi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Create a new, separate Swig compile/render environment.
*
* @example
* var swig = require('swig');
* var myswig = new swig.<span class="apidocCodeKeywordSpan">Swig</span>({varControls: ['&lt;%=', '%&gt;']});
* myswig.render('Tacos are &lt;%= tacos =&gt;!', { locals: { tacos: 'delicious' }});
* // =&gt; Tacos are delicious!
* swig.render('Tacos are &lt;%= tacos =&gt;!', { locals: { tacos: 'delicious' }});
* // =&gt; 'Tacos are &lt;%= tacos =&gt;!'
*
* @param  {SwigOpts} [opts={}] Swig options object.
* @return {object}      New Swig environment.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.swig.compile" id="apidoc.element.swig.swig.compile">
        function <span class="apidocSignatureSpan">swig.swig.</span>compile
        <span class="apidocSignatureSpan">(source, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (source, options) {
  var key = options ? options.filename : null,
    cached = key ? cacheGet(key, options) : null,
    context,
    contextLength,
    pre;

  if (cached) {
    return cached;
  }

  context = getLocals(options);
  contextLength = utils.keys(context).length;
  pre = this.precompile(source, options);

  function compiled(locals) {
    var lcls;
    if (locals &amp;&amp; contextLength) {
      lcls = utils.extend({}, context, locals);
    } else if (locals &amp;&amp; !contextLength) {
      lcls = locals;
    } else if (!locals &amp;&amp; contextLength) {
      lcls = context;
    } else {
      lcls = {};
    }
    return pre.tpl(self, lcls, filters, utils, efn);
  }

  utils.extend(compiled, pre.tokens);

  if (key) {
    cacheSet(key, options, compiled);
  }

  return compiled;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {parserCompiler} compiler
     * @param {array} [args] Array of parsed arguments on the for the token.
     * @param {array} [content] Array of content within the token.
     * @param {array} [parents] Array of parent templates for the current template context.
     * @param {SwigOpts} [options] Swig Options Object
     * @param {string} [blockName] Name of the direct block parent, if any.
     */
    o = token.<span class="apidocCodeKeywordSpan">compile</span>(exports.compile, token.args ? token.args.slice(0) : [], token.content
 ? token.content.slice(0) : [], parents, options, blockName);
    out += o || '';
  });

  return out;
};

},{"./lexer":4,"./utils":26}],9:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.swig.compileFile" id="apidoc.element.swig.swig.compileFile">
        function <span class="apidocSignatureSpan">swig.swig.</span>compileFile
        <span class="apidocSignatureSpan">(pathname, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileFile = function (pathname, options, cb) {
  var src, cached;

  if (!options) {
    options = {};
  }

  pathname = self.options.loader.resolve(pathname, options.resolveFrom);
  if (!options.filename) {
    options = utils.extend({ filename: pathname }, options);
  }
  cached = cacheGet(pathname, options);

  if (cached) {
    if (cb) {
      cb(null, cached);
      return;
    }
    return cached;
  }

  if (cb) {
    self.options.loader.load(pathname, function (err, src) {
      if (err) {
        cb(err);
        return;
      }
      var compiled;

      try {
        compiled = self.compile(src, options);
      } catch (err2) {
        cb(err2);
        return;
      }

      cb(err, compiled);
    });
    return;
  }

  src = self.options.loader.load(pathname);
  return self.compile(src, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;/ul&gt;
```

### node.js code

```js
var swig  = require('swig');
var template = swig.<span class="apidocCodeKeywordSpan">compileFile</span>('/absolute/path/to/template.html');
var output = template({
    pagename: 'awesome people',
    authors: ['Paul', 'Jim', 'Jane']
});
```

### Output
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.swig.invalidateCache" id="apidoc.element.swig.swig.invalidateCache">
        function <span class="apidocSignatureSpan">swig.swig.</span>invalidateCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invalidateCache = function () {
  if (self.options.cache === 'memory') {
    self.cache = {};
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.options.cache.set(key, val);
}

/**
 * Clears the in-memory template cache.
 *
 * @example
 * swig.<span class="apidocCodeKeywordSpan">invalidateCache</span>();
 *
 * @return {undefined}
 */
this.invalidateCache = function () {
  if (self.options.cache === 'memory') {
    self.cache = {};
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.swig.parseFile" id="apidoc.element.swig.swig.parseFile">
        function <span class="apidocSignatureSpan">swig.swig.</span>parseFile
        <span class="apidocSignatureSpan">(pathname, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFile = function (pathname, options) {
  var src;

  if (!options) {
    options = {};
  }

  pathname = self.options.loader.resolve(pathname, options.resolveFrom);

  src = self.options.loader.load(pathname);

  if (!options.filename) {
    options = utils.extend({ filename: pathname }, options);
  }

  return self.parse(src, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    while (parentName) {
if (!options || !options.filename) {
  throw new Error('Cannot extend "' + parentName + '" because current template has no filename.');
}

parentFile = parentFile || options.filename;
parentFile = self.options.loader.resolve(parentName, parentFile);
parent = cacheGet(parentFile, options) || self.<span class="apidocCodeKeywordSpan">parseFile</span>(parentFile, utils.extend({},
options, { filename: parentFile }));
parentName = parent.parent;

if (parentFiles.indexOf(parentFile) !== -1) {
  throw new Error('Illegal circular extends of "' + parentFile + '".');
}
parentFiles.push(parentFile);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.swig.precompile" id="apidoc.element.swig.swig.precompile">
        function <span class="apidocSignatureSpan">swig.swig.</span>precompile
        <span class="apidocSignatureSpan">(source, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">precompile = function (source, options) {
  var tokens = self.parse(source, options),
    parents = getParents(tokens, options),
    tpl,
    err;

  if (parents.length) {
    // Remap the templates first-parent's tokens using this template's blocks.
    tokens.tokens = remapBlocks(tokens.blocks, parents[0].tokens);
    importNonBlocks(tokens.blocks, tokens.tokens);
  }

  try {
    tpl = new Function('_swig', '_ctx', '_filters', '_utils', '_fn',
      '  var _ext = _swig.extensions,\n' +
      '    _output = "";\n' +
      parser.compile(tokens, parents, options) + '\n' +
      '  return _output;\n'
      );
  } catch (e) {
    utils.throwError(e, null, options.filename);
  }

  return { tpl: tpl, tokens: tokens };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (argv.options) {
  swig.setDefaults(require(argv.options));
}

switch (command) {
case 'compile':
  fn = function (file, str) {
var r = swig.<span class="apidocCodeKeywordSpan">precompile</span>(str, { filename: file, locals: ctx }).tpl.toString().replace(&amp;#
x27;anonymous', '');

r = argv['wrap-start'] + r + argv['wrap-end'];

if (argv.m) {
  r = uglify.minify(r, { fromString: true }).code;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.swig.render" id="apidoc.element.swig.swig.render">
        function <span class="apidocSignatureSpan">swig.swig.</span>render
        <span class="apidocSignatureSpan">(source, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (source, options) {
  return self.compile(source, options)();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    out(file, __tpl(swig, ctx, filters, utils, efn));
  }());
};
break;

case 'render':
fn = function (file, str) {
  out(file, swig.<span class="apidocCodeKeywordSpan">render</span>(str, { filename: file, locals: ctx }));
};
break;
}

argv._.forEach(function (file) {
var str = fs.readFileSync(file, 'utf8');
fn(file, str);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.swig.renderFile" id="apidoc.element.swig.swig.renderFile">
        function <span class="apidocSignatureSpan">swig.swig.</span>renderFile
        <span class="apidocSignatureSpan">(pathName, locals, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderFile = function (pathName, locals, cb) {
  if (cb) {
    self.compileFile(pathName, {}, function (err, fn) {
      var result;

      if (err) {
        cb(err);
        return;
      }

      try {
        result = fn(locals);
      } catch (err2) {
        cb(err2);
        return;
      }

      cb(null, result);
    });
    return;
  }

  return self.compileFile(pathName)(locals);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return self.compile(source, options)();
};

/**
 * Compile and render a template file for final output. This is most useful for libraries like Express.js.
 *
 * @example
 * swig.<span class="apidocCodeKeywordSpan">renderFile</span>('./template.html', {}, function (err, output) {
 *   if (err) {
 *     throw err;
 *   }
 *   console.log(output);
 * });
 *
 * @example
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.swig.run" id="apidoc.element.swig.swig.run">
        function <span class="apidocSignatureSpan">swig.swig.</span>run
        <span class="apidocSignatureSpan">(tpl, locals, filepath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (tpl, locals, filepath) {
  var context = getLocals({ locals: locals });
  if (filepath) {
    cacheSet(filepath, {}, tpl);
  }
  return tpl(self, context, filters, utils, efn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Run a pre-compiled template function. This is most useful in the browser when you've pre-compiled your templates with the
 Swig command-line tool.
*
* @example
* $ swig compile ./mytpl.html --wrap-start="var mytpl = " &gt; mytpl.js
* @example
* &lt;script src="mytpl.js"&gt;&lt;/script&gt;
* &lt;script&gt;
*   swig.<span class="apidocCodeKeywordSpan">run</span>(mytpl, {});
*   // =&gt; "rendered template..."
* &lt;/script&gt;
*
* @param  {function} tpl       Pre-compiled Swig template function. Use the Swig CLI to compile your templates.
* @param  {object} [locals={}] Template variable context.
* @param  {string} [filepath]  Filename used for caching the template.
* @return {string}             Rendered output.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.swig.setDefaultTZOffset" id="apidoc.element.swig.swig.setDefaultTZOffset">
        function <span class="apidocSignatureSpan">swig.swig.</span>setDefaultTZOffset
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDefaultTZOffset = function (offset) {
  dateformatter.tzOffset = offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.swig.setDefaults" id="apidoc.element.swig.swig.setDefaults">
        function <span class="apidocSignatureSpan">swig.swig.</span>setDefaults
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDefaults = function (options) {
  validateOptions(options);
  defaultInstance.options = utils.extend(defaultInstance.options, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
utils.each(require(path.resolve(argv.tags)), function (tag, name) {
  swig.setTag(name, tag.parse, tag.compile, tag.ends, tag.block);
});
}

// Specify swig default options
if (argv.options) {
swig.<span class="apidocCodeKeywordSpan">setDefaults</span>(require(argv.options));
}

switch (command) {
case 'compile':
fn = function (file, str) {
  var r = swig.precompile(str, { filename: file, locals: ctx }).tpl.toString().replace('anonymous', '');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.swig.setExtension" id="apidoc.element.swig.swig.setExtension">
        function <span class="apidocSignatureSpan">swig.swig.</span>setExtension
        <span class="apidocSignatureSpan">(name, object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setExtension = function (name, object) {
  self.extensions[name] = object;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
};

/**
 * Add extensions for custom tags. This allows any custom tag to access a globally available methods via a special globally available
 object, &lt;var&gt;_ext&lt;/var&gt;, in templates.
 *
 * @example
 * swig.<span class="apidocCodeKeywordSpan">setExtension</span>('trans', function (v) { return translate(v); });
 * function compileTrans(compiler, args, content, parent, options) {
 *   return '_output += _ext.trans(' + args[0] + ');'
 * };
 * swig.setTag('trans', parseTrans, compileTrans, true);
 *
 * @param  {string} name   Key name of the extension. Accessed via &lt;code data-language="js"&gt;_ext[name]&lt;/
code&gt;.
 * @param  {*}      object The method, value, or object that should be available via the given name.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.swig.setFilter" id="apidoc.element.swig.swig.setFilter">
        function <span class="apidocSignatureSpan">swig.swig.</span>setFilter
        <span class="apidocSignatureSpan">(name, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFilter = function (name, method) {
  if (typeof method !== "function") {
    throw new Error('Filter "' + name + '" is not a valid function.');
  }
  filters[name] = method;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.log('Wrote', argv.o + file);
};
}

// Set any custom filters
if (argv.filters) {
utils.each(require(path.resolve(argv.filters)), function (filter, name) {
  swig.<span class="apidocCodeKeywordSpan">setFilter</span>(name, filter);
});
}

// Set any custom tags
if (argv.tags) {
utils.each(require(path.resolve(argv.tags)), function (tag, name) {
  swig.setTag(name, tag.parse, tag.compile, tag.ends, tag.block);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.swig.setTag" id="apidoc.element.swig.swig.setTag">
        function <span class="apidocSignatureSpan">swig.swig.</span>setTag
        <span class="apidocSignatureSpan">(name, parse, compile, ends, blockLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTag = function (name, parse, compile, ends, blockLevel) {
  if (typeof parse !== 'function') {
    throw new Error('Tag "' + name + '" parse method is not a valid function.');
  }

  if (typeof compile !== 'function') {
    throw new Error('Tag "' + name + '" compile method is not a valid function.');
  }

  tags[name] = {
    parse: parse,
    compile: compile,
    ends: ends || false,
    block: !!blockLevel
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    swig.setFilter(name, filter);
  });
}

// Set any custom tags
if (argv.tags) {
  utils.each(require(path.resolve(argv.tags)), function (tag, name) {
    swig.<span class="apidocCodeKeywordSpan">setTag</span>(name, tag.parse, tag.compile, tag.ends, tag.block);
  });
}

// Specify swig default options
if (argv.options) {
  swig.setDefaults(require(argv.options));
}
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swig.utils" id="apidoc.module.swig.utils">module swig.utils</a></h1>


    <h2>
        <a href="#apidoc.element.swig.utils.each" id="apidoc.element.swig.utils.each">
        function <span class="apidocSignatureSpan">swig.utils.</span>each
        <span class="apidocSignatureSpan">(obj, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">each = function (obj, fn) {
  var i, l;

  if (isArray(obj)) {
    i = 0;
    l = obj.length;
    for (i; i &lt; l; i += 1) {
      if (fn(obj[i], i, obj) === false) {
        break;
      }
    }
  } else {
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (fn(obj[i], i, obj) === false) {
          break;
        }
      }
    }
  }

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fs.writeFileSync(argv.o + file, str, { flags: 'w' });
  console.log('Wrote', argv.o + file);
};
}

// Set any custom filters
if (argv.filters) {
utils.<span class="apidocCodeKeywordSpan">each</span>(require(path.resolve(argv.filters)), function (filter, name) {
  swig.setFilter(name, filter);
});
}

// Set any custom tags
if (argv.tags) {
utils.each(require(path.resolve(argv.tags)), function (tag, name) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.utils.endsWith" id="apidoc.element.swig.utils.endsWith">
        function <span class="apidocSignatureSpan">swig.utils.</span>endsWith
        <span class="apidocSignatureSpan">(str, suffix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endsWith = function (str, suffix) {
  return str.indexOf(suffix, str.length - suffix.length) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var token, lines, stripPrev, prevToken, prevChildToken;

if (!chunk) {
  return;
}

// Is a variable?
if (!inRaw &amp;&amp; utils.startsWith(chunk, varOpen) &amp;&amp; utils.<span class="apidocCodeKeywordSpan">endsWith</span>(
chunk, varClose)) {
  stripPrev = varStripBefore.test(chunk);
  stripNext = varStripAfter.test(chunk);
  token = parseVariable(chunk.replace(varStrip, ''), line);
// Is a tag?
} else if (utils.startsWith(chunk, tagOpen) &amp;&amp; utils.endsWith(chunk, tagClose)) {
  stripPrev = tagStripBefore.test(chunk);
  stripNext = tagStripAfter.test(chunk);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.utils.extend" id="apidoc.element.swig.utils.extend">
        function <span class="apidocSignatureSpan">swig.utils.</span>extend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function () {
  var args = arguments,
    target = args[0],
    objs = (args.length &gt; 1) ? Array.prototype.slice.call(args, 1) : [],
    i = 0,
    l = objs.length,
    key,
    obj;

  for (i; i &lt; l; i += 1) {
    obj = objs[i] || {};
    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        target[key] = obj[key];
      }
    }
  }
  return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  utils.each(input, function (value) {
if (!value.hasOwnProperty(key)) {
  return;
}

var keyname = value[key],
  newVal = utils.<span class="apidocCodeKeywordSpan">extend</span>({}, value);
delete value[key];

if (!out[keyname]) {
  out[keyname] = [];
}

out[keyname].push(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.utils.isArray" id="apidoc.element.swig.utils.isArray">
        function <span class="apidocSignatureSpan">swig.utils.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArray() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {*}
 * @private
 */
function iterateFilter(input) {
var self = this,
  out = {};

if (utils.<span class="apidocCodeKeywordSpan">isArray</span>(input)) {
  return utils.map(input, function (value) {
    return self.apply(null, arguments);
  });
}

if (typeof input === 'object') {
  utils.each(input, function (value, key) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.utils.keys" id="apidoc.element.swig.utils.keys">
        function <span class="apidocSignatureSpan">swig.utils.</span>keys
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keys = function (obj) {
  if (!obj) {
    return [];
  }

  if (Object.keys) {
    return Object.keys(obj);
  }

  return exports.map(obj, function (v, k) {
    return k;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * // T
 *
 * @param  {*} input
 * @return {*}        The first item of the array or first character of the string input.
 */
exports.first = function (input) {
if (typeof input === 'object' &amp;&amp; !utils.isArray(input)) {
  var keys = utils.<span class="apidocCodeKeywordSpan">keys</span>(input);
  return input[keys[0]];
}

if (typeof input === 'string') {
  return input.substr(0, 1);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.utils.map" id="apidoc.element.swig.utils.map">
        function <span class="apidocSignatureSpan">swig.utils.</span>map
        <span class="apidocSignatureSpan">(obj, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (obj, fn) {
  var i = 0,
    result = [],
    l;

  if (isArray(obj)) {
    l = obj.length;
    for (i; i &lt; l; i += 1) {
      result[i] = fn(obj[i], i);
    }
  } else {
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        result[i] = fn(obj[i], i);
      }
    }
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
function iterateFilter(input) {
var self = this,
  out = {};

if (utils.isArray(input)) {
  return utils.<span class="apidocCodeKeywordSpan">map</span>(input, function (value) {
    return self.apply(null, arguments);
  });
}

if (typeof input === 'object') {
  utils.each(input, function (value, key) {
    out[key] = self.apply(null, arguments);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.utils.some" id="apidoc.element.swig.utils.some">
        function <span class="apidocSignatureSpan">swig.utils.</span>some
        <span class="apidocSignatureSpan">(obj, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">some = function (obj, fn) {
  var i = 0,
    result,
    l;
  if (isArray(obj)) {
    l = obj.length;

    for (i; i &lt; l; i += 1) {
      result = fn(obj[i], i, obj);
      if (result) {
        break;
      }
    }
  } else {
    exports.each(obj, function (value, index) {
      result = fn(value, index, obj);
      return !(result);
    });
  }
  return !!result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {string} str String chunk.
 * @return {LexerToken}     Defined type, potentially stripped or replaced with more suitable content.
 * @private
 */
function reader(str) {
  var matched;

  utils.<span class="apidocCodeKeywordSpan">some</span>(rules, function (rule) {
    return utils.some(rule.regex, function (regex) {
var match = str.match(regex),
  normalized;

if (!match) {
  return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.utils.startsWith" id="apidoc.element.swig.utils.startsWith">
        function <span class="apidocSignatureSpan">swig.utils.</span>startsWith
        <span class="apidocSignatureSpan">(str, prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startsWith = function (str, prefix) {
  return str.indexOf(prefix) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param  {number} line The line number that this tag starts on.
   * @return {TagToken}      Parsed token object.
   * @private
   */
  function parseTag(str, line) {
var tokens, parser, chunks, tagName, tag, args, last;

if (utils.<span class="apidocCodeKeywordSpan">startsWith</span>(str, 'end')) {
  last = stack[stack.length - 1];
  if (last &amp;&amp; last.name === str.split(/\s+/)[0].replace(/^end/, '') &amp;&amp; last.ends) {
    switch (last.name) {
    case 'autoescape':
      escape = opts.autoescape;
      break;
    case 'raw':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.utils.strip" id="apidoc.element.swig.utils.strip">
        function <span class="apidocSignatureSpan">swig.utils.</span>strip
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">strip = function (input) {
  return input.replace(/^\s+|\s+$/g, '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Parse a variable.
   * @param  {string} str  String contents of the variable, between &lt;i&gt;{{&lt;/i&gt; and &lt;i&gt;}}&lt;/i&gt;
;
   * @param  {number} line The line number that this variable starts on.
   * @return {VarToken}      Parsed variable token object.
   * @private
   */
  function parseVariable(str, line) {
var tokens = lexer.read(utils.<span class="apidocCodeKeywordSpan">strip</span>(str)),
  parser,
  out;

parser = new TokenParser(tokens, filters, escape, line, opts.filename);
out = parser.parse().join('');

if (parser.state.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swig.utils.throwError" id="apidoc.element.swig.utils.throwError">
        function <span class="apidocSignatureSpan">swig.utils.</span>throwError
        <span class="apidocSignatureSpan">(message, line, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwError = function (message, line, file) {
  if (line) {
    message += ' on line ' + line;
  }
  if (file) {
    message += ' in file ' + file;
  }
  throw new Error(message + '.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ret.load = function (pathname, cb) {
var src, paths;

paths = [pathname, pathname.replace(/^(\/|\\)/, '')];

src = mapping[paths[0]] || mapping[paths[1]];
if (!src) {
  utils.<span class="apidocCodeKeywordSpan">throwError</span>('Unable to find template "' + pathname + '"
;.');
}

if (cb) {
  cb(null, src);
  return;
}
return src;
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>